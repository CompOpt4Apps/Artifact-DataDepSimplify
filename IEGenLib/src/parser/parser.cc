/*!
 * \file parser.cc
 *
 * \brief Implementations to methods declared in parser.h
 *
 * \date Started: 5/17/2010
 * # $Revision:: 622                $: last committed revision
 * # $Date:: 2013-01-18 13:11:32 -0#$: date of last committed revision
 * # $Author:: cathie               $: author of last committed revision
 *
 * \authors Michelle Strout, Alan LaMielle, Nicholas Jeanette
 *
 * Copyright (c) 2009, 2010, 2011, 2012, Colorado State University <br>
 * All rights reserved. <br>
 * See ../../COPYING for details. <br>
*/

#include <parser/parser.h>


// The yyparse() routine will be defined in the c++ file generated by flex.
// gen_parser.cc
extern int yyparse();

using namespace std;

namespace iegenlib{ namespace parser{

   /*! a string of input buffer */
   string input_buffer;

   /*! the integer of our input position */
   unsigned int input_pos;

   /*! boolean flag set when an error occurs in the parser */
   bool parse_error;

   /// error message for when an error occurs in the parser
   string error_message;
   /*! This is used for the actual parsing of the string we pass in we return
   each char of the string
   @return int the value of each char of our string */
   int string_get_next_char() {
      int retchar = 0;

      //If we are not at the end of the input string buffer
      if (input_pos<input_buffer.length() && !parse_error) {
         //Return the next char in the string
         retchar = input_buffer[input_pos];
         input_pos += 1;
      } else {
         //Otherwise return EOF
         retchar = EOF;
      }

      return retchar;
   }

   /*! Environment pointer parse_env_result. */
   Environment* parse_env_result;

   /*! Relation pointer parse_relation_result. */
   Relation* parse_relation_result;

   /*! Set pointer parse_set_result. */
   Set* parse_set_result;
   
   /*! parser_env passes a string representation of an environment 
   to the parser and an Environment gets created.
   @param string env string that is to be parsed
   @return Null pointer if error occurs or an environment is returned
   @return Environment pointer when parsing is successful
   */
   Environment* parse_env(std::string env_string) {
      //reset all fields
      parser::parse_env_result=NULL;
      parser::parse_relation_result=NULL;
      parser::parse_set_result=NULL;
      parse_error = false;
      input_buffer.clear();

      //Set the input buffer to the given env string
      input_buffer=env_string;

      //Set the starting position at the first character
      input_pos=0;

      //Run the parser
      yyparse();

      //if the error flag is set throw an exception
      if(parse_error==true){
         throw parse_exception(error_message);
      }

      //if a relation is returned from yyparse return null
      if(parse_env_result == NULL){
         return NULL;
      }

      return parse_env_result;
   }

   /*! getter for the parse_env_result
   @return Environment* parse_env_result */
   // FIXME: not sure why the other getters do copies.
   // Should change them to be consistent with this one.
   // NOT sure this is even used.
   Environment* get_parse_env_result() {
      return (parse_env_result);
   }

   /*! setter for the parse_env_result
   @param Environment parse_env_result */
   void set_parse_env_result(Environment* e) {
      parser::parse_env_result=e;
   }   
   

   /*!parser_set passes a string representation of a set to the parser and a
   ParseSet gets created.
   @param string set string that is to be parsed
   @return Null pointer if error occurs or a relation is returned
   @return Set pointer when parsing is successful
   */
   Set* parse_set(string set_string)  {
      //reset all fields
      parser::parse_env_result=NULL;
      parser::parse_relation_result=NULL;
      parser::parse_set_result=NULL;
      parse_error = false;
      input_buffer.clear();

      //Set the input buffer to the given set string
      input_buffer=set_string;

      //Set the starting position at the first character
      input_pos=0;

      //Run the parser
      yyparse();

      //if the error flag is set throw an exception
      if(parse_error==true){
         throw parse_exception(error_message);
      }

      //if a relation is returned from yyparse return null
      if(parse_set_result == NULL){
         return NULL;
      }

      return parse_set_result;
   }

   /*! getter for the parse_set_result
   @return Set parse_set_result */
   Set get_parse_set_result() {
      return (*parse_set_result);
   }

   /*! setter for the parse_set_result
   @param Set parse_set_result */
   void set_parse_set_result(Set* s) {
      parser::parse_set_result=s;
   }


   /*! passes a relation string into the parser and creates the Relation
   @param string relation string that is to be parsed
   @return Null pointer if error occurs or a set is returned
   @return Relation pointer when parsing is successful */
   Relation* parse_relation(string relation_string) {
      //reset all fields
      parser::parse_env_result=NULL;
      parser::parse_relation_result=NULL;
      parser::parse_set_result=NULL;
      parse_error = false;
      input_buffer.clear();

      //Set the input buffer to the given relation string
      input_buffer = relation_string;

      //Set the starting position at the first character
      input_pos=0;

      //Run the parser
      yyparse();

      //if error flag is set then throw an exception
      if(parse_error==true){
        throw parse_exception(error_message);
      }

      //if a set is returned from yyparse return null
      if(parse_relation_result==NULL){
         return NULL;
      }

      return parse_relation_result;
   }

   /*! getter for the parse_relation_result
    * the getter can only be called a single time
    * the code that calls it gets a copy of the object
    * and we delete our copy
   @return Relation parse_relation_result */
   Relation get_parse_relation_result() {
      Relation retval = (*parse_relation_result);
      delete parse_relation_result;
      return retval;
   }

   /*! setter for the parse_relation_result
   @param Relation parse_relation_result */
   void set_parse_relation_result(Relation* s) {
      parser::parse_relation_result=s;
   }

   /*! sets the parse_error flag to true */
   void set_parse_error(string error){
      parse_error = true;
      error_message = error;
   }

   /*! getter for the parse_error flag
   @return bool parse_error */
   bool get_parse_error(){
      return parse_error;
   }

   /*! clearAll frees (if needed) and resets the parse_relation_result and the
   parse_set_result so no data is left in those variables*/
   void clearAll(){
      if(parse_relation_result!=NULL){
         delete parse_relation_result;
      }
      if(parse_set_result!=NULL){
         delete parse_set_result;
      }
      parser::parse_relation_result=NULL;
      parser::parse_set_result=NULL;
      input_buffer.clear();
   }

}}//end namespace iegenlib::parser
