source: unroll.c
procedure is foo
format: rose
format rose
LOOP ':' NUMBER   parse the file because we haven't yet
CIT_ROSE
LOOP  ir_code = new IR_roseCode(source_filename, procedure_name);
IR_roseCode::IR_roseCode( file_name unroll.c, proc_name foo )
IR_roseCode::IR_roseCode  actually parsing unroll.c using rose?
"/home/markhall/srcrepository/projects/github/chill/trunk/examples/chill/unroll.c", line 5: warning: 
          variable "k" was declared but never referenced
    int i, j, k;
              ^

IR_roseCode::IR_roseCode()  project defined. file parsed by Rose
creating chillAST from Rose AST
ConvertXXXXVarDecl()
original vartype 'int'
vartype = 'int'
arraypart = ''
int n   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  )
2name n numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'int' 'n' ''"  n_dim 0  )

ConvertXXXXVarDecl()
original vartype 'float *'
vartype = 'float *'
arraypart = ''
float * x   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type float *, name x, arraypart  )
2name x numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float *' 'x' ''"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float *'
vartype = 'float *'
arraypart = ''
float * y   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type float *, name y, arraypart  )
2name y numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float *' 'y' ''"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float *'
vartype = 'float *'
arraypart = ''
float * z   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type float *, name z, arraypart  )
2name z numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float *' 'z' ''"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float *'
vartype = 'float *'
arraypart = ''
float * f3   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type float *, name f3, arraypart  )
2name f3 numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float *' 'f3' ''"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float *'
vartype = 'float *'
arraypart = ''
float * f1   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type float *, name f1, arraypart  )
2name f1 numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float *' 'f1' ''"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float *'
vartype = 'float *'
arraypart = ''
float * w   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type float *, name w, arraypart  )
2name w numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float *' 'w' ''"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'int'
vartype = 'int'
arraypart = ''
int i   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type int, name i, arraypart  )
2name i numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'int' 'i' ''"  n_dim 0  )

ConvertXXXXVarDecl()
original vartype 'int'
vartype = 'int'
arraypart = ''
int j   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type int, name j, arraypart  )
2name j numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'int' 'j' ''"  n_dim 0  )

ConvertXXXXVarDecl()
original vartype 'int'
vartype = 'int'
arraypart = ''
int k   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type int, name k, arraypart  )
2name k numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'int' 'k' ''"  n_dim 0  )

ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'x' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'y' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'z' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'f3' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'f3' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'f1' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'w' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'f3' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'float *' ParmVar  'f3' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
ConvertXXXXVarDecl()
original vartype 'float [14UL]'
vartype = 'float '
arraypart = '[14]'
float  x   arraypart = '[14]'
2chillAST_VarDecl::chillAST_VarDecl( type float , name x, arraypart [14] )
2name x numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float ' 'x' '[14]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float [14UL]'
vartype = 'float '
arraypart = '[14]'
float  y   arraypart = '[14]'
2chillAST_VarDecl::chillAST_VarDecl( type float , name y, arraypart [14] )
2name y numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float ' 'y' '[14]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float [14UL]'
vartype = 'float '
arraypart = '[14]'
float  z   arraypart = '[14]'
2chillAST_VarDecl::chillAST_VarDecl( type float , name z, arraypart [14] )
2name z numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float ' 'z' '[14]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float [14UL]'
vartype = 'float '
arraypart = '[14]'
float  f3   arraypart = '[14]'
2chillAST_VarDecl::chillAST_VarDecl( type float , name f3, arraypart [14] )
2name f3 numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float ' 'f3' '[14]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float [14UL]'
vartype = 'float '
arraypart = '[14]'
float  f1   arraypart = '[14]'
2chillAST_VarDecl::chillAST_VarDecl( type float , name f1, arraypart [14] )
2name f1 numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float ' 'f1' '[14]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'float [14UL]'
vartype = 'float '
arraypart = '[14]'
float  w   arraypart = '[14]'
2chillAST_VarDecl::chillAST_VarDecl( type float , name w, arraypart [14] )
2name w numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'float ' 'w' '[14]'"  n_dim 1  )

ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
unhandled top node 423/429 of type SgSymbolTable
unhandled top node 424/429 of type SgTypeTable
topnode 425 of 429, first == NULL??  blurb numeric_label
unhandled top node 426/429 of type Sg_File_Info
unhandled top node 427/429 of type Sg_File_Info
unhandled top node 428/429 of type SgSourceFile
found the procedure named foo
local Function Definition 0x30c7c00

void foo( int n, float *x, float *y, float *z, float *f3, float *f1, float *w )
{
  int i;
  int j;
  int k;
  for (i = 1; i <= 14; i++) 
    x[i] = 1.0f;
  for (i = 1; i <= 14; i += 3) 
    y[i] = 1.0f;
  for (i = (n + 1); i <= (n + 20); i += 3) 
    z[i] = 1.0f;
  for (i = 0; i <= n; i++) {
    for (j = i; j <= (i + n); j++) 
      f3[i] = (f3[i] + f1[j] * w[j - i]);
    f3[i] = ((float) ((double) f3[i]) * 3.14);
  }

}


printing whole file


// sourcefile has 2 children
they are
FunctionDecl
FunctionDecl

// this source derived from CHILL AST originally from file 'unroll.c' as parsed by frontend compiler rose


void foo( int n, float *x, float *y, float *z, float *f3, float *f1, float *w )
{
  int i;
  int j;
  int k;
  for (i = 1; i <= 14; i++) 
    x[i] = 1.0f;
  for (i = 1; i <= 14; i += 3) 
    y[i] = 1.0f;
  for (i = (n + 1); i <= (n + 20); i += 3) 
    z[i] = 1.0f;
  for (i = 0; i <= n; i++) {
    for (j = i; j <= (i + n); j++) 
      f3[i] = (f3[i] + f1[j] * w[j - i]);
    f3[i] = ((float) ((double) f3[i]) * 3.14);
  }

}

int main(  )
{
  float  x[14];
  float  y[14];
  float  z[14];
  float  f3[14];
  float  f1[14];
  float  w[14];
  foo(14, x, y, z, f3, f1, w);
  return(0);

}

//CHILL AST originally from file 'unroll.c'

(FunctionDecl void foo(int n, float *x, float *y, float *z, float *f3, float *f1, float *w)
  (CompoundStmt 
    (VarDecl "'int' 'i' ''"  n_dim 0  )
    (VarDecl "'int' 'j' ''"  n_dim 0  )
    (VarDecl "'int' 'k' ''"  n_dim 0  )
    (ForStmt 
      (BinaryOperator '='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 1)
      )
      (BinaryOperator '<='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 14)
      )
      (UnaryOperator postfix ++
        (DeclRefExpr 'int' Var  'i' )
      )
      (CompoundStmt 
        (BinaryOperator '='
          (ArraySubscriptExpr (x) 'float' lvalue
            (DeclRefExpr 'float *' ParmVar  'x' )
            (DeclRefExpr 'int' Var  'i' )
          )
          (CStyleCastExpr  (float) 
            (FloatingLiteral 'double' 1.000000)
          )
        )
      )
    )
    (ForStmt 
      (BinaryOperator '='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 1)
      )
      (BinaryOperator '<='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 14)
      )
      (BinaryOperator '+='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 3)
      )
      (CompoundStmt 
        (BinaryOperator '='
          (ArraySubscriptExpr (y) 'float' lvalue
            (DeclRefExpr 'float *' ParmVar  'y' )
            (DeclRefExpr 'int' Var  'i' )
          )
          (CStyleCastExpr  (float) 
            (FloatingLiteral 'double' 1.000000)
          )
        )
      )
    )
    (ForStmt 
      (BinaryOperator '='
        (DeclRefExpr 'int' Var  'i' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' ParmVar  'n' )
          (IntegerLiteral 'int' 1)
        )
      )
      (BinaryOperator '<='
        (DeclRefExpr 'int' Var  'i' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' ParmVar  'n' )
          (IntegerLiteral 'int' 20)
        )
      )
      (BinaryOperator '+='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 3)
      )
      (CompoundStmt 
        (BinaryOperator '='
          (ArraySubscriptExpr (z) 'float' lvalue
            (DeclRefExpr 'float *' ParmVar  'z' )
            (DeclRefExpr 'int' Var  'i' )
          )
          (CStyleCastExpr  (float) 
            (FloatingLiteral 'double' 1.000000)
          )
        )
      )
    )
    (ForStmt 
      (BinaryOperator '='
        (DeclRefExpr 'int' Var  'i' )
        (IntegerLiteral 'int' 0)
      )
      (BinaryOperator '<='
        (DeclRefExpr 'int' Var  'i' )
        (DeclRefExpr 'int' ParmVar  'n' )
      )
      (UnaryOperator postfix ++
        (DeclRefExpr 'int' Var  'i' )
      )
      (CompoundStmt 
        (ForStmt 
          (BinaryOperator '='
            (DeclRefExpr 'int' Var  'j' )
            (DeclRefExpr 'int' Var  'i' )
          )
          (BinaryOperator '<='
            (DeclRefExpr 'int' Var  'j' )
            (BinaryOperator '+'
              (DeclRefExpr 'int' Var  'i' )
              (DeclRefExpr 'int' ParmVar  'n' )
            )
          )
          (UnaryOperator postfix ++
            (DeclRefExpr 'int' Var  'j' )
          )
          (CompoundStmt 
            (BinaryOperator '='
              (ArraySubscriptExpr (f3) 'float' lvalue
                (DeclRefExpr 'float *' ParmVar  'f3' )
                (DeclRefExpr 'int' Var  'i' )
              )
              (BinaryOperator '+'
                (ArraySubscriptExpr (f3) 'float' rvalue
                  (DeclRefExpr 'float *' ParmVar  'f3' )
                  (DeclRefExpr 'int' Var  'i' )
                )
                (BinaryOperator '*'
                  (ArraySubscriptExpr (f1) 'float' rvalue
                    (DeclRefExpr 'float *' ParmVar  'f1' )
                    (DeclRefExpr 'int' Var  'j' )
                  )
                  (ArraySubscriptExpr (w) 'float' rvalue
                    (DeclRefExpr 'float *' ParmVar  'w' )
                    (BinaryOperator '-'
                      (DeclRefExpr 'int' Var  'j' )
                      (DeclRefExpr 'int' Var  'i' )
                    )
                  )
                )
              )
            )
          )
        )
        (BinaryOperator '='
          (ArraySubscriptExpr (f3) 'float' lvalue
            (DeclRefExpr 'float *' ParmVar  'f3' )
            (DeclRefExpr 'int' Var  'i' )
          )
          (CStyleCastExpr  (float) 
            (BinaryOperator '*'
              (CStyleCastExpr  (double) 
                (ArraySubscriptExpr (f3) 'float' rvalue
                  (DeclRefExpr 'float *' ParmVar  'f3' )
                  (DeclRefExpr 'int' Var  'i' )
                )
              )
              (FloatingLiteral 'double' 3.140000)
            )
          )
        )
      )
    )
  )
)

(FunctionDecl int main()
  (CompoundStmt 
    (VarDecl "'float ' 'x' '[14]'"  n_dim 1  )
    (VarDecl "'float ' 'y' '[14]'"  n_dim 1  )
    (VarDecl "'float ' 'z' '[14]'"  n_dim 1  )
    (VarDecl "'float ' 'f3' '[14]'"  n_dim 1  )
    (VarDecl "'float ' 'f1' '[14]'"  n_dim 1  )
    (VarDecl "'float ' 'w' '[14]'"  n_dim 1  )
    (CallExpr void
      (DeclRefExpr 'void' 'foo' ( int n, float *x, float *y, float *z, float *f3, float *f1, float *w ))
      (VarDecl "'int' 'n' ''"  n_dim 0  )
      (VarDecl "'float *' 'x' ''"  n_dim 1  )
      (VarDecl "'float *' 'y' ''"  n_dim 1  )
      (VarDecl "'float *' 'z' ''"  n_dim 1  )
      (VarDecl "'float *' 'f3' ''"  n_dim 1  )
      (VarDecl "'float *' 'f1' ''"  n_dim 1  )
      (VarDecl "'float *' 'w' ''"  n_dim 1  )
    )
    (ReturnStmt
      (IntegerLiteral 'int' 0)
    )
  )
)
need to create symbol tables?
LOOP RETURN ir_code = new IR_roseCode(source_filename, procedure_name);
yyparse  block = ir_code->GetCode();
IR_roseCode::GetCode()
chillfunc 0x30c7c00
chillast body of func is 0x30c8350
making a new IR_roseBlock with chillAST

void foo( int n, float *x, float *y, float *z, float *f3, float *f1, float *w )
{
  int i;
  int j;
  int k;
  for (i = 1; i <= 14; i++) 
    x[i] = 1.0f;
  for (i = 1; i <= 14; i += 3) 
    y[i] = 1.0f;
  for (i = (n + 1); i <= (n + 20); i += 3) 
    z[i] = 1.0f;
  for (i = 0; i <= n; i++) {
    for (j = i; j <= (i + n); j++) 
      f3[i] = (f3[i] + f1[j] * w[j - i]);
    f3[i] = ((float) ((double) f3[i]) * 3.14);
  }

}

in yyparse, IR_Block block 0x30c17e0

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type FunctionDecl

void foo( int n, float *x, float *y, float *z, float *f3, float *f1, float *w )
{
  int i;
  int j;
  int k;
  for (i = 1; i <= 14; i++) 
    x[i] = 1.0f;
  for (i = 1; i <= 14; i += 3) 
    y[i] = 1.0f;
  for (i = (n + 1); i <= (n + 20); i += 3) 
    z[i] = 1.0f;
  for (i = 0; i <= n; i++) {
    for (j = i; j <= (i + n); j++) 
      f3[i] = (f3[i] + f1[j] * w[j - i]);
    f3[i] = ((float) ((double) f3[i]) * 3.14);
  }

}



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
basic block has 7 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/7 is of type VarDecl
straight line code adding to basicblock that had 0
child 0/7 = int i
child 0 is part of a basic block
now basicblock has 1 statements
child 1/7 is of type VarDecl
straight line code adding to basicblock that had 1
child 1/7 = int j
child 1 is part of a basic block
now basicblock has 2 statements
child 2/7 is of type VarDecl
straight line code adding to basicblock that had 2
child 2/7 = int k
child 2 is part of a basic block
now basicblock has 3 statements
child 3/7 is of type ForStmt
found a For statement (Loop) at 3/7 within a Basic Block
pushing a run of statements 0 to 2 as a block
making a new IR_roseBlock with NO chillAST (nil)
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = 1; i <= 14; i++) 
  x[i] = 1.0f;

IR_roseLoop::IR_roseLoop()    chillbody
body is:
x[i] = 1.0f;


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
child 4/7 is of type ForStmt
found a For statement (Loop) at 4/7 within a Basic Block
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = 1; i <= 14; i += 3) 
  y[i] = 1.0f;

IR_roseLoop::IR_roseLoop()    chillbody
body is:
y[i] = 1.0f;


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
child 5/7 is of type ForStmt
found a For statement (Loop) at 5/7 within a Basic Block
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = (n + 1); i <= (n + 20); i += 3) 
  z[i] = 1.0f;

IR_roseLoop::IR_roseLoop()    chillbody
body is:
z[i] = 1.0f;


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
child 6/7 is of type ForStmt
found a For statement (Loop) at 6/7 within a Basic Block
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = 0; i <= n; i++) {
  for (j = i; j <= (i + n); j++) 
    f3[i] = (f3[i] + f1[j] * w[j - i]);
  f3[i] = ((float) ((double) f3[i]) * 3.14);
}

IR_roseLoop::IR_roseLoop()    chillbody
body is:
for (j = i; j <= (i + n); j++) 
  f3[i] = (f3[i] + f1[j] * w[j - i]);
f3[i] = ((float) ((double) f3[i]) * 3.14);


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
ns 0  numchildren 7

*** block is a compoundstatement or a function decl  END 
returning vector of 5 controls
(parser.yy) I found 4 loops in the procedure

parse.yy  L 505 making a new myloop loop num start 2

***                                                   ROSE (parser.yy) making a new myloop

Loop::Loop(const IR_Control *control)
control type is 0   IR_CONTROL_LOOP
in Loop::Loop, calling  build_ir_tree()

loop.cc, Loop::Loop() about to clone control
IR_roseLoop::clone()
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = (n + 1); i <= (n + 20); i += 3) 
  z[i] = 1.0f;

IR_roseLoop::IR_roseLoop()    chillbody
body is:
z[i] = 1.0f;


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
case IR_CONTROL_LOOP
recursing. build_ir_tree() of CONTROL_LOOP creating children  L122
IR_roseLoop::body()
making a new IR_roseBlock with chillAST
z[i] = 1.0f;

irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type CompoundStmt
z[i] = 1.0f;



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
found a top level Basic Block Compound Statement
basic block has 1 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/1 is of type BinaryOperator
straight line code adding to basicblock that had 0
child 0/1 = z[i] = 1.0f
child 0 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 1
NOT sending straightline run of statements, because it would be the entire block. There are no control statements in the block

*** block is a compoundstatement or a function decl  END 
returning vector of 0 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 0
build_ir_tree()  vector result has 1 parts
recursing. build_ir_tree() of CONTROL_LOOP creating children DONE
build_ir_tree()  vector result has 1 parts
in Loop::Loop. ir_tree has 1 parts
before init_loops, 0 freevar
dammit 0

                                                  Loop::init_loop()
extract
nesting level stmt size = 1
1 statements?
i 0
stmt_nesting_level[0] = 1
in init_loop, made 1 stmts
max nesting level 1 at location 0
itn = stmt[0]
parent
IR_CONTROL_LOOP  cur_dim 0
making scalar symbol i
index[0] = 'i'
align loops by names,

set relation variable names                      ****
Relation r(1)
it's a loop.  temp_depth 0
r.name_set_var( 1, i )
Relation r   {[i] : TRUE }
extract information from loop/if structures
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
n + 1

exp2formula()
{[i] : TRUE }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_PLUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[i] : exists ( e1,e2 : ( e1+e2 <= i )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && e1+e2 <= i )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
n + 20

IR_roseLoop::stop_cond()
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && 1 = e2 && e1+e2 <= i )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_PLUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && 1 = e2 && e1+e2 <= i )) and exists ( e3,e4 : ( i <= e3+e4 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && 1 = e2 && e1+e2 <= i )) and exists ( e3,e4 : ( n = e3 && i <= e3+e4 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
IR_roseLoop::lower_bound()
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && 1 = e2 && e1+e2 <= i )) and exists ( e3,e4 : ( n = e3 && 20 = e4 && i <= e3+e4 )) and exists ( alpha : ( exists ( beta : i = 3beta+alpha) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_PLUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && 1 = e2 && e1+e2 <= i )) and exists ( e3,e4 : ( n = e3 && 20 = e4 && i <= e3+e4 )) and exists ( alpha : ( exists ( beta : i = 3beta+alpha) and exists ( e5,e6 : ( e5+e6 = alpha )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
exp2formula()
{ Sym=[n] [i] : exists ( e1,e2 : ( n = e1 && 1 = e2 && e1+e2 <= i )) and exists ( e3,e4 : ( n = e3 && 20 = e4 && i <= e3+e4 )) and exists ( alpha : ( exists ( beta : i = 3beta+alpha) and exists ( e5,e6 : ( e5+e6 = alpha && n = e5 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
add information for missing loops   n_dim(1)
loop.cc L441 insert the statement
loop.cc before extract
IR_roseBlock::extract()
block has chillAST of type CompoundStmt
block has 0 exploded statements
IR_roseBlock::extract() LEAVING
code =  ocg->CreateSubstitutedStmt(...)


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
0 vars and 0 substitutions
1 nodes in old code. was:
stmt(0) = z[i] = 1.0f

nosubs old code was:
stmt = z[i] = 1.0f
stmt
for int i < n_dim(1)
whew
                                        loop.cc   Loop::init_loop() END

after init_loops, 1 freevar
loop.cc 1 statements
this really REALLY needs some comments
i 0
j 0

irtools.cc test_data_dependences()  1 freevars
repr1   z[i] = 1.0f
repr2   z[i] = 1.0f
index 0 i
IS1  { Sym=[n] [i] : exists ( alpha : 1+n+3alpha = i && i-19 <= n < i) }
IS2  { Sym=[n] [i] : exists ( alpha : 1+n+3alpha = i && i-19 <= n < i) }
repr1 == repr2
repr1->dump()
z[i] = 1.0f
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = z[i] = 1.0f
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for z
z
1 total refs 
ref[0] z is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'z' write 1
access of size 1
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
WRITE  array access 0 = z
that was the list


before mapRefstoStatements()
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
 IR_roseCode::FromSameStmt()
z[i]
z[i]
trivially true because they are exactly the same statement
after mapRefstoStatements()

i 0
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
sym_a = z
j 0
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
sym_b = z
irtools.cc ij 0 0
*sym_a == *sym_b
0 a->is_write()
0 b->is_write()

irtools.cc ij 0 0   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i] : exists ( alpha : 1+n+3alpha = i && i-19 <= n < i) }
IS2  { Sym=[n] [i] : exists ( alpha : 1+n+3alpha = i && i-19 <= n < i) }
r    {[In_1] -> [Out_1] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i] -> [i'] : exists ( e7,e8 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i] -> [i'] : exists ( e7,e8 : ( i = e7 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base z
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( z )
IR_roseArraySymbol::IR_roseArraySymbol (z)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i] -> [i'] : exists ( e7,e8 : ( i = e7 && i' = e8 && e8 = e7 )) and exists ( alpha : 1+n+3alpha = i && i-19 <= n < i) and exists ( alpha : 1+n+3alpha = i' && i'-19 <= n < i') }
leaving arrays2relation
r    { Sym=[n] [i] -> [i'] : exists ( e7,e8 : ( i = e7 && i' = e8 && e8 = e7 )) and exists ( alpha : 1+n+3alpha = i && i-19 <= n < i) and exists ( alpha : 1+n+3alpha = i' && i'-19 <= n < i') }
1
relation2dependences()
{ Sym=[n] [In_1] : exists ( i,i' : ( exists ( alpha : 1+n = i+3alpha && i' = i && i' = i+In_1 && i-19 <= n < i) )) }

dv created in if                                         ***
leaving relation2dependences, 0 and 0 dependences

irtools.cc ij 0 0 dv.first 0   dv.second 0
234LEAVING test_data_dependences()  first size 0    second size 0

dv.first.size() 0


*** LOTS OF REDUCTIONS ***


i range 1
i 0
loop.cc reducCand.size() 0
loop.cc canReduce.size() 0
init dumb transformation relations
                                                  at bottom of Loop::Loop, printCode


                             parser 1          unroll( a,b,c )
loop.cc apply_xform( set )
{[i] -> [chill_t1] : i = chill_t1 }
FIX THIS rose in generic loop.cc
loop vars 0 i
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t1' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
1 uninterpreted symbols
loop vars 0 i
CG_utils.cc  output_substitutions()
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[i] = 1.0f
sub 0  chill_t1

subbing chill_t1
for  i

SubABinaryOperator() subbing old variable i in 
z[i] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
loop.cc LEAVING apply_xform( set )

loop.cc apply_xform( set )
{[chill_t1] -> [chill_t2] : chill_t1 = chill_t2 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t1
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t2' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
1 uninterpreted symbols
loop vars 0 chill_t1
CG_utils.cc  output_substitutions()
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t1] = 1.0f
sub 0  chill_t2

subbing chill_t2
for  chill_t1

SubABinaryOperator() subbing old variable chill_t1 in 
z[chill_t1] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
loop.cc LEAVING apply_xform( set )

loop.cc apply_xform( set )
{[chill_t2] -> [chill_t3] : chill_t2 = chill_t3 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
1 uninterpreted symbols
loop vars 0 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t2] = 1.0f
sub 0  chill_t3

subbing chill_t3
for  chill_t2

SubABinaryOperator() subbing old variable chill_t2 in 
z[chill_t2] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
loop.cc LEAVING apply_xform( set )

loop_unroll.cc, will replace 'chill_t3 with 'chill_t3+3' ??
CG_chillBuilder::CreateInt( 3 )
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
loop_unroll.cc subs  now has 1 parts
old src was =
z[chill_t3] = 1.0f
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  chill_t3 + 3

subbing chill_t3 + 3
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
old src is =
z[chill_t3] = 1.0f
substituted copy is =
z[chill_t3 + 3] = 1.0f
appended code =
z[chill_t3 + 3] = 1.0f
loop_unroll.cc, will replace 'chill_t3 with 'chill_t3+6' ??
CG_chillBuilder::CreateInt( 6 )
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
loop_unroll.cc subs  now has 1 parts
old src was =
z[chill_t3] = 1.0f
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  chill_t3 + 6

subbing chill_t3 + 6
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
old src is =
z[chill_t3] = 1.0f
substituted copy is =
z[chill_t3 + 6] = 1.0f
appended code =
z[chill_t3 + 3] = 1.0f
z[chill_t3 + 6] = 1.0f
loop_unroll.cc, will replace 'chill_t3 with 'chill_t3+9' ??
CG_chillBuilder::CreateInt( 9 )
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
loop_unroll.cc subs  now has 1 parts
old src was =
z[chill_t3] = 1.0f
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  chill_t3 + 9

subbing chill_t3 + 9
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
old src is =
z[chill_t3] = 1.0f
substituted copy is =
z[chill_t3 + 9] = 1.0f
appended code =
z[chill_t3 + 3] = 1.0f
z[chill_t3 + 6] = 1.0f
z[chill_t3 + 9] = 1.0f
loop_unroll.cc, will replace 'chill_t3 with 'chill_t3+12' ??
CG_chillBuilder::CreateInt( 12 )
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
loop_unroll.cc subs  now has 1 parts
old src was =
z[chill_t3] = 1.0f
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  chill_t3 + 12

subbing chill_t3 + 12
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
old src is =
z[chill_t3] = 1.0f
substituted copy is =
z[chill_t3 + 12] = 1.0f
appended code =
z[chill_t3 + 3] = 1.0f
z[chill_t3 + 6] = 1.0f
z[chill_t3 + 9] = 1.0f
z[chill_t3 + 12] = 1.0f
loop_unroll.cc, will replace 'chill_t3 with 'chill_t3+15' ??
CG_chillBuilder::CreateInt( 15 )
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
loop_unroll.cc subs  now has 1 parts
old src was =
z[chill_t3] = 1.0f
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  chill_t3 + 15

subbing chill_t3 + 15
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
old src is =
z[chill_t3] = 1.0f
substituted copy is =
z[chill_t3 + 15] = 1.0f
appended code =
z[chill_t3 + 3] = 1.0f
z[chill_t3 + 6] = 1.0f
z[chill_t3 + 9] = 1.0f
z[chill_t3 + 12] = 1.0f
z[chill_t3 + 15] = 1.0f
loop_unroll.cc, will replace 'chill_t3 with 'chill_t3+18' ??
CG_chillBuilder::CreateInt( 18 )
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
loop_unroll.cc subs  now has 1 parts
old src was =
z[chill_t3] = 1.0f
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  chill_t3 + 18

subbing chill_t3 + 18
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
old src is =
z[chill_t3] = 1.0f
substituted copy is =
z[chill_t3 + 18] = 1.0f
appended code =
z[chill_t3 + 3] = 1.0f
z[chill_t3 + 6] = 1.0f
z[chill_t3 + 9] = 1.0f
z[chill_t3 + 12] = 1.0f
z[chill_t3 + 15] = 1.0f
z[chill_t3 + 18] = 1.0f
new_stmt.IS = 
update dependence graph
                                                  loop_unroll.cc returning new_stmts
CodeGen::CodeGen() sanity checking
num_stmt 2  2 xforms
here goes
here goes
CodeGen::CodeGen() DONE
CG.cc line 164, CG_result::printString()
stmts.size() 2

CG_result::printRepr(ocg, stmts) 
DYINGHERE
s 0/2
result: t2 = Out_1, 0
s 1/2
result: t2 = Out_1, 0
return printRepr( ... )
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
s0(n+1);
s1(n+1);

(parser.yy) I found 4 loops in the procedure
have to update <clang/rose/suif> Intermediate Representation before changing the next loop
replacing code for a single loop in <clang/rose/suif> IR

Loop::getCode( 1 )

CG_result::printRepr(ocg, stmts) 
DYINGHERE
s 0/2
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from 
(DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
s 1/2
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
return printRepr( ... )
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = z[chill_t3] = 1.0f
sub 0  n + 1

subbing n + 1
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
1.0  1.0
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
6 nodes in old code. was:
stmt(0) = z[chill_t3 + 3] = 1.0f
stmt(1) = z[chill_t3 + 6] = 1.0f
stmt(2) = z[chill_t3 + 9] = 1.0f
stmt(3) = z[chill_t3 + 12] = 1.0f
stmt(4) = z[chill_t3 + 15] = 1.0f
stmt(5) = z[chill_t3 + 18] = 1.0f
sub 0  n + 1

subbing n + 1
for  chill_t3

SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3 + 3] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t3 + 3
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 3)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3 + 6] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t3 + 6
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 6)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3 + 9] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t3 + 9
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 9)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3 + 12] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t3 + 12
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 12)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3 + 15] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t3 + 15
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 15)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t3 in 
z[chill_t3 + 18] = 1.0f
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (FloatingLiteral 'double' 1.000000)
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t3 + 18
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 18)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
IR_roseCode::ReplaceCode( old, *repr)
old was
for (i = (n + 1); i <= (n + 20); i += 3) 
  z[chill_t3] = 1.0f;


old parent was

{
int i;
int j;
int k;
for (i = 1; i <= 14; i++) 
  x[i] = 1.0f;
for (i = 1; i <= 14; i += 3) 
  y[i] = 1.0f;
for (i = (n + 1); i <= (n + 20); i += 3) 
  z[chill_t3] = 1.0f;
for (i = 0; i <= n; i++) {
  for (j = i; j <= (i + n); j++) 
    f3[i] = (f3[i] + f1[j] * w[j - i]);
  f3[i] = ((float) ((double) f3[i]) * 3.14);
}


}
inserting z[(n + 1) + 3] = 1.0f
inserting z[(n + 1) + 6] = 1.0f
inserting z[(n + 1) + 9] = 1.0f
inserting z[(n + 1) + 12] = 1.0f
inserting z[(n + 1) + 15] = 1.0f
inserting z[(n + 1) + 18] = 1.0f

new parent2 is

{
int i;
int j;
int k;
for (i = 1; i <= 14; i++) 
  x[i] = 1.0f;
;
for (i = 1; i <= 14; i += 3) 
  y[i] = 1.0f;
;
z[n + 1] = 1.0f;
z[(n + 1) + 3] = 1.0f;
z[(n + 1) + 6] = 1.0f;
z[(n + 1) + 9] = 1.0f;
z[(n + 1) + 12] = 1.0f;
z[(n + 1) + 15] = 1.0f;
z[(n + 1) + 18] = 1.0f;
for (i = 0; i <= n; i++) {
  for (j = i; j <= (i + n); j++) 
    f3[i] = (f3[i] + f1[j] * w[j - i]);
  f3[i] = ((float) ((double) f3[i]) * 3.14);
}
;
}

parse.yy  L 505 making a new myloop loop num start 3

***                                                   ROSE (parser.yy) making a new myloop

Loop::Loop(const IR_Control *control)
control type is 0   IR_CONTROL_LOOP
in Loop::Loop, calling  build_ir_tree()

loop.cc, Loop::Loop() about to clone control
IR_roseLoop::clone()
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = 0; i <= n; i++) {
  for (j = i; j <= (i + n); j++) 
    f3[i] = (f3[i] + f1[j] * w[j - i]);
  f3[i] = ((float) ((double) f3[i]) * 3.14);
}

IR_roseLoop::IR_roseLoop()    chillbody
body is:
for (j = i; j <= (i + n); j++) 
  f3[i] = (f3[i] + f1[j] * w[j - i]);
f3[i] = ((float) ((double) f3[i]) * 3.14);


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
case IR_CONTROL_LOOP
recursing. build_ir_tree() of CONTROL_LOOP creating children  L122
IR_roseLoop::body()
making a new IR_roseBlock with chillAST
for (j = i; j <= (i + n); j++) 
  f3[i] = (f3[i] + f1[j] * w[j - i]);
f3[i] = ((float) ((double) f3[i]) * 3.14);

irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type CompoundStmt
for (j = i; j <= (i + n); j++) 
  f3[i] = (f3[i] + f1[j] * w[j - i]);
f3[i] = ((float) ((double) f3[i]) * 3.14);



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
found a top level Basic Block Compound Statement
basic block has 2 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/2 is of type ForStmt
found a For statement (Loop) at 0/2 within a Basic Block
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (j = i; j <= (i + n); j++) 
  f3[i] = (f3[i] + f1[j] * w[j - i]);

IR_roseLoop::IR_roseLoop()    chillbody
body is:
f3[i] = (f3[i] + f1[j] * w[j - i]);


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
child 1/2 is of type BinaryOperator
straight line code adding to basicblock that had 0
child 1/2 = f3[i] = ((float) ((double) f3[i]) * 3.14)
child 1 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 2
end of body ends the run of 1 statements in the Basic Block

*** block is a compoundstatement or a function decl  END 
returning vector of 2 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 2  (NONZERO)
controls[0] is IR_CONTROL_LOOP
IR_roseLoop::body()
making a new IR_roseBlock with chillAST
f3[i] = (f3[i] + f1[j] * w[j - i]);

irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type CompoundStmt
f3[i] = (f3[i] + f1[j] * w[j - i]);



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
found a top level Basic Block Compound Statement
basic block has 1 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/1 is of type BinaryOperator
straight line code adding to basicblock that had 0
child 0/1 = f3[i] = (f3[i] + f1[j] * w[j - i])
child 0 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 1
NOT sending straightline run of statements, because it would be the entire block. There are no control statements in the block

*** block is a compoundstatement or a function decl  END 
returning vector of 0 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 0
build_ir_tree()  vector result has 1 parts
controls[1] is IR_CONTROL_BLOCK
irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
blockast CB is NULL.   instead, 1 statements
stmt 0:  f3[i] = ((float) ((double) f3[i]) * 3.14)

*** block is a compoundstatement or a function decl or NULL
basic block has 1 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/1 is of type BinaryOperator
straight line code adding to basicblock that had 0
child 0/1 = f3[i] = ((float) ((double) f3[i]) * 3.14)
child 0 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 1
NOT sending straightline run of statements, because it would be the entire block. There are no control statements in the block

*** block is a compoundstatement or a function decl  END 
returning vector of 0 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 0
build_ir_tree()  vector result has 1 parts
build_ir_tree()  vector result has 2 parts
recursing. build_ir_tree() of CONTROL_LOOP creating children DONE
build_ir_tree()  vector result has 1 parts
in Loop::Loop. ir_tree has 1 parts
before init_loops, 0 freevar
dammit 0

                                                  Loop::init_loop()
extract
nesting level stmt size = 2
2 statements?
i 0
stmt_nesting_level[0] = 2
i 1
stmt_nesting_level[1] = 1
in init_loop, made 2 stmts
max nesting level 2 at location 0
itn = stmt[0]
parent
IR_CONTROL_LOOP  cur_dim 1
making scalar symbol j
index[1] = 'j'
parent
IR_CONTROL_LOOP  cur_dim 0
making scalar symbol i
index[0] = 'i'
align loops by names,

set relation variable names                      ****
Relation r(2)
it's a loop.  temp_depth 1
r.name_set_var( 2, j )
it's a loop.  temp_depth 0
r.name_set_var( 1, i )
Relation r   {[i,j] : TRUE }
extract information from loop/if structures
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
i

exp2formula()
{[i,j] : TRUE }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
i + n

IR_roseLoop::stop_cond()
exp2formula()
{[i,j] : i <= j }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_PLUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[i,j] : i <= j and exists ( e11,e12 : ( j <= e11+e12 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,j] : i <= j and exists ( e11,e12 : ( i = e11 && j <= e11+e12 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
0

exp2formula()
{ Sym=[n] [i,j] : i <= j and exists ( e11,e12 : ( i = e11 && n = e12 && j <= e11+e12 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
n

IR_roseLoop::stop_cond()
exp2formula()
{ Sym=[n] [i,j] : 0 <= i <= j and exists ( e11,e12 : ( i = e11 && n = e12 && j <= e11+e12 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
add information for missing loops   n_dim(2)
loop.cc L441 insert the statement
loop.cc before extract
IR_roseBlock::extract()
block has chillAST of type CompoundStmt
block has 0 exploded statements
IR_roseBlock::extract() LEAVING
code =  ocg->CreateSubstitutedStmt(...)


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
0 vars and 0 substitutions
1 nodes in old code. was:
stmt(0) = f3[i] = (f3[i] + f1[j] * w[j - i])

nosubs old code was:
stmt = f3[i] = (f3[i] + f1[j] * w[j - i])
stmt
for int i < n_dim(2)
whew
max nesting level 1 at location 1
align loops by names,

set relation variable names                      ****
Relation r(2)
it's a loop.  temp_depth 0
r.name_set_var( 1, i )
Relation r   {[i,In_2] : TRUE }
extract information from loop/if structures
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
0

exp2formula()
{[i,In_2] : TRUE }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
n

IR_roseLoop::stop_cond()
exp2formula()
{[i,In_2] : 0 <= i }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
add information for missing loops   n_dim(2)
IR_roseLoop::upper_bound()
exp2formula()
{ Sym=[n] [i,In_2] : 0 <= i <= n }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_PLUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{ Sym=[n] [i,In_2] : 0 <= i <= n and exists ( e13,e14 : ( e13+e14 = In_2 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{ Sym=[n] [i,In_2] : 0 <= i <= n and exists ( e13,e14 : ( e13+e14 = In_2 && i = e13 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  n
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     n
making scalar symbol n
s n
loop.cc L441 insert the statement
loop.cc before extract
IR_roseBlock::extract()
block has 1 exploded statements
adding a statement from IR_roseBlock::extract()
IR_roseBlock::extract() LEAVING
code =  ocg->CreateSubstitutedStmt(...)


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
0 vars and 0 substitutions
1 nodes in old code. was:
stmt(0) = f3[i] = ((float) ((double) f3[i]) * 3.14)

nosubs old code was:
stmt = f3[i] = ((float) ((double) f3[i]) * 3.14)
stmt
for int i < n_dim(2)
whew
                                        loop.cc   Loop::init_loop() END

after init_loops, 1 freevar
loop.cc 2 statements
this really REALLY needs some comments
i 0
j 0

irtools.cc test_data_dependences()  1 freevars
repr1   f3[i] = (f3[i] + f1[j] * w[j - i])
repr2   f3[i] = (f3[i] + f1[j] * w[j - i])
index 0 i
index 1 j
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
repr1 == repr2
repr1->dump()
f3[i] = (f3[i] + f1[j] * w[j - i])
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = f3[i] = (f3[i] + f1[j] * w[j - i])
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for f3
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for f3
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for f1
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for w
f3
f3
f1
w
f3
f3
f1
w
f3
f3
f1
w
f3
f3
f1
w
4 total refs 
ref[0] f3 is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 1
ref[1] f3 is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 0
ref[2] f1 is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f1' write 0
ref[3] w is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'w' write 0
access of size 4
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
WRITE  array access 0 = f3
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
       array access 1 = f3
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
       array access 2 = f1
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
       array access 3 = w
that was the list


before mapRefstoStatements()
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
 IR_roseCode::FromSameStmt()
f3[i]
f3[i]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
 IR_roseCode::FromSameStmt()
f3[i]
f3[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] = (f3[i] + f1[j] * w[j - i])
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] + f1[j] * w[j - i]
f3[i] = (f3[i] + f1[j] * w[j - i])
f3[i] + f1[j] * w[j - i]
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
 IR_roseCode::FromSameStmt()
f3[i]
f1[j]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] = (f3[i] + f1[j] * w[j - i])
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f1[j]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f1[j] * w[j - i]
f3[i] = (f3[i] + f1[j] * w[j - i])
f1[j] * w[j - i]
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
 IR_roseCode::FromSameStmt()
f3[i]
w[j - i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] = (f3[i] + f1[j] * w[j - i])
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
w[j - i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f1[j] * w[j - i]
f3[i] = (f3[i] + f1[j] * w[j - i])
f1[j] * w[j - i]
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
 IR_roseCode::FromSameStmt()
f3[i]
f3[i]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
 IR_roseCode::FromSameStmt()
f3[i]
f1[j]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] + f1[j] * w[j - i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f1[j]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f1[j] * w[j - i]
f3[i] + f1[j] * w[j - i]
f1[j] * w[j - i]
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
 IR_roseCode::FromSameStmt()
f3[i]
w[j - i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] + f1[j] * w[j - i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
w[j - i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f1[j] * w[j - i]
f3[i] + f1[j] * w[j - i]
f1[j] * w[j - i]
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
 IR_roseCode::FromSameStmt()
f1[j]
f1[j]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
 IR_roseCode::FromSameStmt()
f1[j]
w[j - i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f1[j]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f1[j] * w[j - i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
w[j - i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f1[j] * w[j - i]
f1[j] * w[j - i]
f1[j] * w[j - i]
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
 IR_roseCode::FromSameStmt()
w[j - i]
w[j - i]
trivially true because they are exactly the same statement
after mapRefstoStatements()

i 0
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_a = f3
j 0
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_b = f3
irtools.cc ij 0 0
*sym_a == *sym_b
0 a->is_write()
0 b->is_write()

irtools.cc ij 0 0   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,j] -> [i',j'] : exists ( e15,e16 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,j] -> [i',j'] : exists ( e15,e16 : ( i = e15 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,j] -> [i',j'] : exists ( e15,e16 : ( i = e15 && i' = e16 && e16 = e15 )) and 0 <= i <= j, n && j <= i+n and 0 <= i' <= j', n && j' <= i'+n }
leaving arrays2relation
r    { Sym=[n] [i,j] -> [i',j'] : exists ( e15,e16 : ( i = e15 && i' = e16 && e16 = e15 )) and 0 <= i <= j, n && j <= i+n and 0 <= i' <= j', n && j' <= i'+n }
1
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',j' : ( i' = i && i' = i+In_1 && j' = j+In_2 && 0 <= i <= j, n, j' && j <= i+n && j' <= i+n )) }
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',j' : ( i = i' && i' = i+In_1 && j' = j+In_2 && 0 <= i' <= j, n, j' && j <= i'+n && j' <= i'+n )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol f3

dv goes out of scope                                      ***

dv created in if                                         ***
leaving relation2dependences, 1 and 0 dependences
dependences1[0]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2W
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)

irtools.cc ij 0 0 dv.first 1   dv.second 0
2IR_roseArraySymbol::IR_roseArraySymbol (f3)
34IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
j 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_b = f3
irtools.cc ij 0 1
*sym_a == *sym_b
0 a->is_write()
1 b->is_NOT_write()

irtools.cc ij 0 1   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,j] -> [i',j'] : exists ( e17,e18 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,j] -> [i',j'] : exists ( e17,e18 : ( i = e17 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,j] -> [i',j'] : exists ( e17,e18 : ( i = e17 && i' = e18 && e18 = e17 )) and 0 <= i <= j, n && j <= i+n and 0 <= i' <= j', n && j' <= i'+n }
leaving arrays2relation
r    { Sym=[n] [i,j] -> [i',j'] : exists ( e17,e18 : ( i = e17 && i' = e18 && e18 = e17 )) and 0 <= i <= j, n && j <= i+n and 0 <= i' <= j', n && j' <= i'+n }
1
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',j' : ( i' = i && i' = i+In_1 && j' = j+In_2 && 0 <= i <= j, n, j' && j <= i+n && j' <= i+n )) }
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',j' : ( i = i' && i' = i+In_1 && j' = j+In_2 && 0 <= i' <= j, n, j' && j <= i'+n && j' <= i'+n )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol f3

dv goes out of scope                                      ***

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences2
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences2
dependences2[0]: symbol f3

dv goes out of scope                                      ***

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol f3
dependences1[1]: symbol f3

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 1 dependences
dependences1[0]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2R
dependences1[1]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2R
symbol f3  HAS A right DEPENDENCE OF TYPE DEP_R2W
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)

irtools.cc ij 0 1 dv.first 2   dv.second 1
2IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
3IR_roseArraySymbol::IR_roseArraySymbol (f3)
4IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
j 2
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
sym_b = f1
irtools.cc ij 0 2
*sym_a NOT == *sym_b
0 a->is_write()
2 b->is_NOT_write()
j 3
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
sym_b = w
irtools.cc ij 0 3
*sym_a NOT == *sym_b
0 a->is_write()
3 b->is_NOT_write()
i 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_a = f3
j 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_b = f3
irtools.cc ij 1 1
*sym_a == *sym_b
1 a->is_NOT_write()
1 b->is_NOT_write()
j 2
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
sym_b = f1
irtools.cc ij 1 2
*sym_a NOT == *sym_b
1 a->is_NOT_write()
2 b->is_NOT_write()
j 3
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
sym_b = w
irtools.cc ij 1 3
*sym_a NOT == *sym_b
1 a->is_NOT_write()
3 b->is_NOT_write()
i 2
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
sym_a = f1
j 2
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
sym_b = f1
irtools.cc ij 2 2
*sym_a == *sym_b
2 a->is_NOT_write()
2 b->is_NOT_write()
j 3
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
sym_b = w
irtools.cc ij 2 3
*sym_a NOT == *sym_b
2 a->is_NOT_write()
3 b->is_NOT_write()
i 3
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
sym_a = w
j 3
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
sym_b = w
irtools.cc ij 3 3
*sym_a == *sym_b
3 a->is_NOT_write()
3 b->is_NOT_write()
LEAVING test_data_dependences()  first size 6    second size 2

dv.first.size() 6
k1 0
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 1
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 2
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 3
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 4
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 5
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k2 0
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k2 1
IR_roseArraySymbol::IR_roseArraySymbol (f3)
j 1

irtools.cc test_data_dependences()  1 freevars
repr1   f3[i] = (f3[i] + f1[j] * w[j - i])
repr2   f3[i] = ((float) ((double) f3[i]) * 3.14)
index 0 i
index 1 j
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }

repr1 != repr2
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = f3[i] = (f3[i] + f1[j] * w[j - i])
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for f3
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for f3
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for f1
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for w
f3
f3
f1
w
f3
f3
f1
w
f3
f3
f1
w
f3
f3
f1
w
4 total refs 
ref[0] f3 is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 1
ref[1] f3 is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 0
ref[2] f1 is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f1' write 0
ref[3] w is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'w' write 0
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = f3[i] = ((float) ((double) f3[i]) * 3.14)
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for f3
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for f3
f3
f3
f3
f3
2 total refs 
ref[0] f3 is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 1
ref[1] f3 is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 0
i 0
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,j] -> [i',In_2'] : exists ( e19,e20 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,j] -> [i',In_2'] : exists ( e19,e20 : ( i = e19 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,j] -> [i',In_2'] : exists ( e19,e20 : ( i = e19 && i' = e20 && e20 = e19 )) and 0 <= i <= j, n && j <= i+n and n+i' = In_2' && n <= In_2' <= 2n }
leaving arrays2relation
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',In_2' : ( i'+n = In_2' && i = i' && i' = i+In_1 && In_2' = j+In_2 && 0 <= i' <= j <= In_2' && 2i' <= In_2' )) }
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',In_2' : ( n+i = In_2' && n+i' = In_2' && i' = i+In_1 && In_2' = j+In_2 && n, j <= In_2' <= 2n && In_2' <= j+n )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol f3

dv goes out of scope                                      ***

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol f3
dependences1[1]: symbol f3

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 0 dependences
dependences1[0]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2W
dependences1[1]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2W
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,j] -> [i',In_2'] : exists ( e21,e22 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,j] -> [i',In_2'] : exists ( e21,e22 : ( i = e21 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,j] -> [i',In_2'] : exists ( e21,e22 : ( i = e21 && i' = e22 && e22 = e21 )) and 0 <= i <= j, n && j <= i+n and n+i' = In_2' && n <= In_2' <= 2n }
leaving arrays2relation
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',In_2' : ( i'+n = In_2' && i = i' && i' = i+In_1 && In_2' = j+In_2 && 0 <= i' <= j <= In_2' && 2i' <= In_2' )) }
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',In_2' : ( n+i = In_2' && n+i' = In_2' && i' = i+In_1 && In_2' = j+In_2 && n, j <= In_2' <= 2n && In_2' <= j+n )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol f3

dv goes out of scope                                      ***

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol f3
dependences1[1]: symbol f3

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 0 dependences
dependences1[0]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2R
dependences1[1]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2R
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
i 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,j] : 0 <= i <= j, n && j <= i+n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,j] -> [i',In_2'] : exists ( e23,e24 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,j] -> [i',In_2'] : exists ( e23,e24 : ( i = e23 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,j] -> [i',In_2'] : exists ( e23,e24 : ( i = e23 && i' = e24 && e24 = e23 )) and 0 <= i <= j, n && j <= i+n and n+i' = In_2' && n <= In_2' <= 2n }
leaving arrays2relation
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',In_2' : ( i'+n = In_2' && i = i' && i' = i+In_1 && In_2' = j+In_2 && 0 <= i' <= j <= In_2' && 2i' <= In_2' )) }
{ Sym=[n] [In_1,In_2] : exists ( i,j,i',In_2' : ( n+i = In_2' && n+i' = In_2' && i' = i+In_1 && In_2' = j+In_2 && n, j <= In_2' <= 2n && In_2' <= j+n )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol f3

dv goes out of scope                                      ***

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol f3
dependences1[1]: symbol f3

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 0 dependences
dependences1[0]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_R2W
dependences1[1]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_R2W
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
i 2
IR_roseArrayRef::symbol()
base f1
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f1 )
IR_roseArraySymbol::IR_roseArraySymbol (f1)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
i 3
IR_roseArrayRef::symbol()
base w
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( w )
IR_roseArraySymbol::IR_roseArraySymbol (w)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
LEAVING test_data_dependences()  first size 6    second size 0

dv.first.size() 6
k1 0
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 1
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 2
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 3
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 4
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 5
IR_roseArraySymbol::IR_roseArraySymbol (f3)
i 1
j 1

irtools.cc test_data_dependences()  1 freevars
repr1   f3[i] = ((float) ((double) f3[i]) * 3.14)
repr2   f3[i] = ((float) ((double) f3[i]) * 3.14)
index 0 i
index 1 j
IS1  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
repr1 == repr2
repr1->dump()
f3[i] = ((float) ((double) f3[i]) * 3.14)
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = f3[i] = ((float) ((double) f3[i]) * 3.14)
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for f3
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for f3
f3
f3
f3
f3
2 total refs 
ref[0] f3 is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 1
ref[1] f3 is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'f3' write 0
access of size 2
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
WRITE  array access 0 = f3
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
       array access 1 = f3
that was the list


before mapRefstoStatements()
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
 IR_roseCode::FromSameStmt()
f3[i]
f3[i]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
 IR_roseCode::FromSameStmt()
f3[i]
f3[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
f3[i] = ((float) ((double) f3[i]) * 3.14)
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
f3[i]
chillAST_node::getEnclosingStatement( level 1 ) node type CStyleCastExpr
((double) f3[i])
chillAST_node::getEnclosingStatement( level 2 ) node type BinaryOperator
((double) f3[i]) * 3.14
f3[i] = ((float) ((double) f3[i]) * 3.14)
((double) f3[i]) * 3.14
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
 IR_roseCode::FromSameStmt()
f3[i]
f3[i]
trivially true because they are exactly the same statement
after mapRefstoStatements()

i 0
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_a = f3
j 0
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_b = f3
irtools.cc ij 0 0
*sym_a == *sym_b
0 a->is_write()
0 b->is_write()

irtools.cc ij 0 0   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,In_2] -> [i',In_2'] : exists ( e25,e26 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,In_2] -> [i',In_2'] : exists ( e25,e26 : ( i = e25 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,In_2] -> [i',In_2'] : exists ( e25,e26 : ( i = e25 && i' = e26 && e26 = e25 )) and n+i = In_2 && n <= In_2 <= 2n and n+i' = In_2' && n <= In_2' <= 2n }
leaving arrays2relation
r    { Sym=[n] [i,In_2] -> [i',In_2'] : exists ( e25,e26 : ( i = e25 && i' = e26 && e26 = e25 )) and n+i = In_2 && n <= In_2 <= 2n and n+i' = In_2' && n <= In_2' <= 2n }
1
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,In_2,i',In_2' : ( In_2' = In_2 && i+n = In_2 && i' = i && i' = i+In_1 && In_2' = In_2+In_2 && 0 <= i && 2i <= In_2 )) }
{ Sym=[n] [In_1,In_2] : exists ( i,In_2,i',In_2' : ( In_2 = In_2' && n+i' = In_2' && n+i = In_2' && i' = i+In_1 && In_2' = In_2+In_2 && n <= In_2' <= 2n )) }

dv created in if                                         ***
leaving relation2dependences, 0 and 0 dependences

irtools.cc ij 0 0 dv.first 0   dv.second 0
234j 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_b = f3
irtools.cc ij 0 1
*sym_a == *sym_b
0 a->is_write()
1 b->is_NOT_write()

irtools.cc ij 0 1   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
1 freevars
freevar 0 n
IS1  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
IS2  { Sym=[n] [i,In_2] : n+i = In_2 && n <= In_2 <= 2n }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[i,In_2] -> [i',In_2'] : exists ( e27,e28 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[i,In_2] -> [i',In_2'] : exists ( e27,e28 : ( i = e27 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::n_dim() 1
r    { Sym=[n] [i,In_2] -> [i',In_2'] : exists ( e27,e28 : ( i = e27 && i' = e28 && e28 = e27 )) and n+i = In_2 && n <= In_2 <= 2n and n+i' = In_2' && n <= In_2' <= 2n }
leaving arrays2relation
r    { Sym=[n] [i,In_2] -> [i',In_2'] : exists ( e27,e28 : ( i = e27 && i' = e28 && e28 = e27 )) and n+i = In_2 && n <= In_2 <= 2n and n+i' = In_2' && n <= In_2' <= 2n }
1
relation2dependences()
{ Sym=[n] [In_1,In_2] : exists ( i,In_2,i',In_2' : ( In_2' = In_2 && i+n = In_2 && i' = i && i' = i+In_1 && In_2' = In_2+In_2 && 0 <= i && 2i <= In_2 )) }
{ Sym=[n] [In_1,In_2] : exists ( i,In_2,i',In_2' : ( In_2 = In_2' && n+i' = In_2' && n+i = In_2' && i' = i+In_1 && In_2' = In_2+In_2 && n <= In_2' <= 2n )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
symbol f3  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (f3)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol f3

dv goes out of scope                                      ***
leaving relation2dependences, 1 and 0 dependences
dependences1[0]: symbol f3
symbol f3  HAS A left  DEPENDENCE OF TYPE DEP_W2R
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)

irtools.cc ij 0 1 dv.first 1   dv.second 0
2IR_roseArraySymbol::IR_roseArraySymbol (f3)
34IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
i 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_a = f3
j 1
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArrayRef::symbol()
base f3
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( f3 )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
sym_b = f3
irtools.cc ij 1 1
*sym_a == *sym_b
1 a->is_NOT_write()
1 b->is_NOT_write()
LEAVING test_data_dependences()  first size 2    second size 0

dv.first.size() 2
k1 0
IR_roseArraySymbol::IR_roseArraySymbol (f3)
k1 1
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)


*** LOTS OF REDUCTIONS ***


i range 2
i 0
dep.hasEdge(0, 0)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
tdv size 8
ij 0 0
ij 0 1
ij 0 2
ij 0 3
ij 0 4
ij 0 5
ij 0 6
ij 0 7
i 1
dep.hasEdge(1, 1)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
tdv size 2
ij 1 0
ij 1 1
loop.cc reducCand.size() 0
loop.cc canReduce.size() 0
init dumb transformation relations
                                                  at bottom of Loop::Loop, printCode
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)


                             parser 1          unroll( a,b,c )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
loop.cc apply_xform( set )
{[i,j] -> [chill_t1,chill_t2] : i = chill_t1 && j = chill_t2 }
FIX THIS rose in generic loop.cc
loop vars 0 i
loop vars 1 j
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t1' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t2' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
2 uninterpreted symbols
loop vars 0 i
loop vars 1 j
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[i] = (f3[i] + f1[j] * w[j - i])
sub 0  chill_t1
sub 1  chill_t2

subbing chill_t1
for  i
subbing chill_t2
for  j

SubABinaryOperator() subbing old variable i in 
f3[i] = (f3[i] + f1[j] * w[j - i])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'i' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'j' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'j' )
        (DeclRefExpr 'int' Var  'i' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable i in 
f3[i] + f1[j] * w[j - i]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'j' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'j' )
      (DeclRefExpr 'int' Var  'i' )
    )
  )
)

SubABinaryOperator() subbing old variable i in 
f1[j] * w[j - i]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'j' )
    (DeclRefExpr 'int' Var  'i' )
  )
)

SubABinaryOperator() subbing old variable i in 
j - i
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'i' )

SubABinaryOperator() subbing old variable j in 
f3[chill_t1] = (f3[chill_t1] + f1[j] * w[j - chill_t1])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t1' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'j' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'j' )
        (DeclRefExpr 'int' Var  'chill_t1' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable j in 
f3[chill_t1] + f1[j] * w[j - chill_t1]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'j' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'j' )
      (DeclRefExpr 'int' Var  'chill_t1' )
    )
  )
)

SubABinaryOperator() subbing old variable j in 
f1[j] * w[j - chill_t1]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'j' )
    (DeclRefExpr 'int' Var  'chill_t1' )
  )
)

SubABinaryOperator() subbing old variable j in 
j - chill_t1
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t1' )

{[i,In_2] -> [chill_t1,chill_t2] : i = chill_t1 && In_2 = chill_t2 }
FIX THIS rose in generic loop.cc
loop vars 0 i
loop vars 1 In_2
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t1' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t2' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 1
2 uninterpreted symbols
loop vars 0 i
loop vars 1 In_2
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[i] = ((float) ((double) f3[i]) * 3.14)
sub 0  chill_t1
sub 1  chill_t2

subbing chill_t1
for  i
subbing chill_t2
for  In_2

SubABinaryOperator() subbing old variable i in 
f3[i] = ((float) ((double) f3[i]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'i' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable i in 
((double) f3[i]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
SubABinaryOperator() subbing old variable In_2 in 
f3[chill_t1] = ((float) ((double) f3[chill_t1]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t1' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable In_2 in 
((double) f3[chill_t1]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
loop.cc LEAVING apply_xform( set )

CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateIntegerMod()   NEEDS WORK
LHS 1 + n
RHS 2
CG_chillBuilder::CreateIdent( over1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name over1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'over1' )
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateIdent( over1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name over1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'over1' )
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseCode::FindScalarRef()
looking for scalar variables in 
over1 = ((1 + n) % 2)
(BinaryOperator '='
  (DeclRefExpr 'int' Var  'over1' )
  (BinaryOperator '%'
    (BinaryOperator '+'
      (IntegerLiteral 'int' 1)
      (DeclRefExpr 'int' Var  'n' )
    )
    (IntegerLiteral 'int' 2)
  )
)
found 2 variables set in that code
over1
n
loop.cc apply_xform( set )
{[chill_t1,chill_t2] -> [chill_t3,chill_t4] : chill_t1 = chill_t3 && chill_t2 = chill_t4 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t1
loop vars 1 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t4' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
3 uninterpreted symbols
loop vars 0 chill_t1
loop vars 1 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t1] = (f3[chill_t1] + f1[chill_t2] * w[chill_t2 - chill_t1])
sub 0  chill_t3
sub 1  chill_t4

subbing chill_t3
for  chill_t1
subbing chill_t4
for  chill_t2

SubABinaryOperator() subbing old variable chill_t1 in 
f3[chill_t1] = (f3[chill_t1] + f1[chill_t2] * w[chill_t2 - chill_t1])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t1' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t2' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t2' )
        (DeclRefExpr 'int' Var  'chill_t1' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t1 in 
f3[chill_t1] + f1[chill_t2] * w[chill_t2 - chill_t1]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t2' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t2' )
      (DeclRefExpr 'int' Var  'chill_t1' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t1 in 
f1[chill_t2] * w[chill_t2 - chill_t1]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t2' )
    (DeclRefExpr 'int' Var  'chill_t1' )
  )
)

SubABinaryOperator() subbing old variable chill_t1 in 
chill_t2 - chill_t1
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t1' )

SubABinaryOperator() subbing old variable chill_t2 in 
f3[chill_t3] = (f3[chill_t3] + f1[chill_t2] * w[chill_t2 - chill_t3])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t2' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t2' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t2 in 
f3[chill_t3] + f1[chill_t2] * w[chill_t2 - chill_t3]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t2' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t2' )
      (DeclRefExpr 'int' Var  'chill_t3' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t2 in 
f1[chill_t2] * w[chill_t2 - chill_t3]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t2' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
)

SubABinaryOperator() subbing old variable chill_t2 in 
chill_t2 - chill_t3
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t3' )

{[chill_t1,chill_t2] -> [chill_t3,chill_t4] : chill_t1 = chill_t3 && chill_t2 = chill_t4 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t1
loop vars 1 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t4' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 1
3 uninterpreted symbols
loop vars 0 chill_t1
loop vars 1 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t1] = ((float) ((double) f3[chill_t1]) * 3.14)
sub 0  chill_t3
sub 1  chill_t4

subbing chill_t3
for  chill_t1
subbing chill_t4
for  chill_t2

SubABinaryOperator() subbing old variable chill_t1 in 
f3[chill_t1] = ((float) ((double) f3[chill_t1]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t1' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t1 in 
((double) f3[chill_t1]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
SubABinaryOperator() subbing old variable chill_t2 in 
f3[chill_t3] = ((float) ((double) f3[chill_t3]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t2 in 
((double) f3[chill_t3]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
loop.cc LEAVING apply_xform( set )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
3.14  3.14
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
loop.cc apply_xform( set )
{[chill_t3,chill_t4] -> [chill_t5,chill_t6] : chill_t3 = chill_t5 && chill_t4 = chill_t6 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t3
loop vars 1 chill_t4
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t5 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t5, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t5' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t6 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t6, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t6' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
5 uninterpreted symbols
loop vars 0 chill_t3
loop vars 1 chill_t4
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t3] = (f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3])
sub 0  chill_t5
sub 1  chill_t6

subbing chill_t5
for  chill_t3
subbing chill_t6
for  chill_t4

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] = (f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t4' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t4' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t4' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t4' )
      (DeclRefExpr 'int' Var  'chill_t3' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
f1[chill_t4] * w[chill_t4 - chill_t3]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t4' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t4 - chill_t3
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t3' )

SubABinaryOperator() subbing old variable chill_t4 in 
f3[chill_t5] = (f3[chill_t5] + f1[chill_t4] * w[chill_t4 - chill_t5])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t4' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t4' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
f3[chill_t5] + f1[chill_t4] * w[chill_t4 - chill_t5]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t4' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t4' )
      (DeclRefExpr 'int' Var  'chill_t5' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
f1[chill_t4] * w[chill_t4 - chill_t5]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t4' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
chill_t4 - chill_t5
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t5' )

{[chill_t3,chill_t4] -> [chill_t5,chill_t6] : chill_t3 = chill_t5 && chill_t4 = chill_t6 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t3
loop vars 1 chill_t4
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t5 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t5, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t5' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t6 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t6, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t6' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 1
5 uninterpreted symbols
loop vars 0 chill_t3
loop vars 1 chill_t4
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t3] = ((float) ((double) f3[chill_t3]) * 3.14)
sub 0  chill_t5
sub 1  chill_t6

subbing chill_t5
for  chill_t3
subbing chill_t6
for  chill_t4

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] = ((float) ((double) f3[chill_t3]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t3 in 
((double) f3[chill_t3]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
SubABinaryOperator() subbing old variable chill_t4 in 
f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t4 in 
((double) f3[chill_t5]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
loop.cc LEAVING apply_xform( set )

CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateIdent( chill_t5 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t5, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t5' )
CG_chillBuilder::CreatePlus()
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
sub 0  chill_t5 + 1

subbing chill_t5 + 1
for  chill_t5

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  'chill_t5' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - chill_t5]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - chill_t5
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t5' )

CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateIdent( chill_t5 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t5, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t5' )
CG_chillBuilder::CreatePlus()
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
3.14  3.14
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14)
sub 0  chill_t5 + 1

subbing chill_t5 + 1
for  chill_t5

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t5 in 
((double) f3[chill_t5]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
IR_roseArraySymbol::IR_roseArraySymbol (f3)
                                                  loop_unroll.cc returning new_stmts
CodeGen::CodeGen() sanity checking
num_stmt 7  7 xforms
here goes
here goes
here goes
here goes
here goes
here goes
here goes
CodeGen::CodeGen() DONE
CG.cc line 164, CG_result::printString()
stmts.size() 7

CG_result::printRepr(ocg, stmts) 
DYINGHERE
s 0/7
result: t2 = Out_1, 0
result: t4 = Out_1, 0
s 1/7
result: t2 = Out_1, 0
result: t4 = Out_1, 0
s 2/7
s 3/7
result: t2 = Out_1, 0
result: t4 = Out_1, 0
s 4/7
result: t2 = Out_1, 0
result: t4 = Out_1, 0
s 5/7
result: t2 = Out_1, 0
result: t4 = Out_1, 0
s 6/7
result: t2 = Out_1, 0
result: t4 = Out_1, 0
return printRepr( ... )
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
then_cond  { Sym=[n] [t1,t2,t3,t4,t5] : 0 <= n }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
{ Sym=[n] [t1,t2,t3,t4,t5] : TRUE and 0 <= n }
{[t1,t2,t3,t4,t5]: 0 <= n}
{ Sym=[n] [t1,t2,t3,t4,t5] : 0 <= n }
{[t1,t2,t3,t4,t5]: 0 <= n}
CG_utils.cc loop_print_repr recursive 3
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_utils.cc loop_print_repr recursive 4
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
then_cond  { Sym=[n] [t1,t2,t3,t4,t5] : 1 <= n }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
{ Sym=[n] [t1,t2,t3,t4,t5] : TRUE and 1 <= n }
{[t1,t2,t3,t4,t5]: 1 <= n}
{ Sym=[n] [t1,t2,t3,t4,t5] : 1 <= n }
{[t1,t2,t3,t4,t5]: 1 <= n}
CG_utils.cc loop_print_repr recursive 3
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_utils.cc loop_print_repr recursive 4
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5] : t2 < t4 }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  { Sym=[over1] [t1,t2,t3,t4,t5] : 1 <= over1 }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5] : 0 <= t2 }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
if (n >= 0) {
  s2();
}
for(t2 = 0; t2 <= n-over1; t2 += 2) {
  if (n >= 1) {
    s0(t2,t2);
  }
  for(t4 = t2+1; t4 <= t2+n-1; t4++) {
    s0(t2,t4);
    s5(t2,t4);
  }
  s0(t2,t2+n);
  s1(t2,t2+n);
  if (t2+n >= t2+1) {
    s5(t2,t2+n);
  }
  s5(t2,t2+n+1);
  s6(t2,t2+n+1);
}
if (over1 >= 1) {
  for(t4 = n; t4 <= 2*n-1; t4++) {
    s3(n,t4);
  }
  if (n >= 0) {
    s3(n,2*n);
    s4(n,2*n);
  }
}

script success!
parser.yy almost done
1 loop?   (loop_num_start == loop_num_end)

Loop::getCode( 1 )

CG_result::printRepr(ocg, stmts) 
DYINGHERE
s 0/7
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from 
(DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
s 1/7
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
s 2/7
s 3/7
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
s 4/7
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
s 5/7
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
s 6/7
result: t2 = Out_1, 0
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
return printRepr( ... )
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
then_cond  { Sym=[n] [t1,t2,t3,t4,t5] : 0 <= n }
output_guard()
GEQ
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateLE()
result =  ocg->CreateAnd(result, term);
CG_chillBuilder::CreateAnd()
{ Sym=[n] [t1,t2,t3,t4,t5] : TRUE and 0 <= n }
{[t1,t2,t3,t4,t5]: 0 <= n}
{ Sym=[n] [t1,t2,t3,t4,t5] : 0 <= n }
{[t1,t2,t3,t4,t5]: 0 <= n}
CG_utils.cc loop_print_repr recursive 3
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
CG_utils.cc  output_substitutions()          DONE



in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
0 vars and 0 substitutions
1 nodes in old code. was:
stmt(0) = over1 = ((1 + n) % 2)

nosubs old code was:
stmt = over1 = ((1 + n) % 2)
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_chillBuilder::CreateIf()
CG_utils.cc loop_print_repr recursive 4
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( over1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name over1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'over1' )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )

CG_chillBuilder::CreateInductive()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
then_cond  { Sym=[n] [t1,t2,t3,t4,t5] : 1 <= n }
output_guard()
GEQ
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateLE()
result =  ocg->CreateAnd(result, term);
CG_chillBuilder::CreateAnd()
{ Sym=[n] [t1,t2,t3,t4,t5] : TRUE and 1 <= n }
{[t1,t2,t3,t4,t5]: 1 <= n}
{ Sym=[n] [t1,t2,t3,t4,t5] : 1 <= n }
{[t1,t2,t3,t4,t5]: 1 <= n}
CG_utils.cc loop_print_repr recursive 3
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
sub 0  t2
sub 1  t2

subbing t2
for  chill_t5
subbing t2
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  'chill_t5' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - chill_t5]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - chill_t5
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t5' )

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] = (f3[t2] + f1[chill_t6] * w[chill_t6 - t2])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  't2' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  't2' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] + f1[chill_t6] * w[chill_t6 - t2]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  't2' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
f1[chill_t6] * w[chill_t6 - t2]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  't2' )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
chill_t6 - t2
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  't2' )

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_chillBuilder::CreateIf()
CG_utils.cc loop_print_repr recursive 4
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )

CG_chillBuilder::CreateInductive()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
sub 0  t2
sub 1  t4

subbing t2
for  chill_t5
subbing t4
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  'chill_t5' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - chill_t5]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - chill_t5
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t5' )

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] = (f3[t2] + f1[chill_t6] * w[chill_t6 - t2])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  't2' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  't2' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] + f1[chill_t6] * w[chill_t6 - t2]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  't2' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
f1[chill_t6] * w[chill_t6 - t2]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  't2' )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
chill_t6 - t2
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  't2' )

CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5 + 1] = (f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)])
sub 0  t2
sub 1  t4

subbing t2
for  chill_t5
subbing t4
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] = (f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t5' )
      (IntegerLiteral 'int' 1)
    )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'chill_t5' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (BinaryOperator '+'
        (DeclRefExpr 'int' Var  'chill_t5' )
        (IntegerLiteral 'int' 1)
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t5' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - (chill_t5 + 1)
op -   rhs type BinaryOperator
(BinaryOperator '+'
  (DeclRefExpr 'int' Var  'chill_t5' )
  (IntegerLiteral 'int' 1)
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] = (f3[t2 + 1] + f1[chill_t6] * w[chill_t6 - (t2 + 1)])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  't2' )
      (IntegerLiteral 'int' 1)
    )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  't2' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] + f1[chill_t6] * w[chill_t6 - (t2 + 1)]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (BinaryOperator '+'
        (DeclRefExpr 'int' Var  't2' )
        (IntegerLiteral 'int' 1)
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f1[chill_t6] * w[chill_t6 - (t2 + 1)]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  't2' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
chill_t6 - (t2 + 1)
op -   rhs type BinaryOperator
(BinaryOperator '+'
  (DeclRefExpr 'int' Var  't2' )
  (IntegerLiteral 'int' 1)
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
sub 0  t2
sub 1  t2 + n

subbing t2
for  chill_t5
subbing t2 + n
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  'chill_t5' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - chill_t5]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  'chill_t5' )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - chill_t5
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t5' )

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] = (f3[t2] + f1[chill_t6] * w[chill_t6 - t2])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  't2' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (DeclRefExpr 'int' Var  't2' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] + f1[chill_t6] * w[chill_t6 - t2]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (DeclRefExpr 'int' Var  't2' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
f1[chill_t6] * w[chill_t6 - t2]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (DeclRefExpr 'int' Var  't2' )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
chill_t6 - t2
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  't2' )

CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
3.14  3.14
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14)
sub 0  t2
sub 1  t2 + n

subbing t2
for  chill_t5
subbing t2 + n
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t5' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t5 in 
((double) f3[chill_t5]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2] = ((float) ((double) f3[t2]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  't2' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t6 in 
((double) f3[t2]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5] : t2 < t4 }
output_guard()
GEQ
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateLE()
result =  ocg->CreateAnd(result, term);
CG_chillBuilder::CreateAnd()
CG_chillBuilder::CreateAnd()
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5 + 1] = (f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)])
sub 0  t2
sub 1  t2 + n

subbing t2
for  chill_t5
subbing t2 + n
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] = (f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t5' )
      (IntegerLiteral 'int' 1)
    )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'chill_t5' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (BinaryOperator '+'
        (DeclRefExpr 'int' Var  'chill_t5' )
        (IntegerLiteral 'int' 1)
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t5' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - (chill_t5 + 1)
op -   rhs type BinaryOperator
(BinaryOperator '+'
  (DeclRefExpr 'int' Var  'chill_t5' )
  (IntegerLiteral 'int' 1)
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] = (f3[t2 + 1] + f1[chill_t6] * w[chill_t6 - (t2 + 1)])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  't2' )
      (IntegerLiteral 'int' 1)
    )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  't2' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] + f1[chill_t6] * w[chill_t6 - (t2 + 1)]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (BinaryOperator '+'
        (DeclRefExpr 'int' Var  't2' )
        (IntegerLiteral 'int' 1)
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f1[chill_t6] * w[chill_t6 - (t2 + 1)]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  't2' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
chill_t6 - (t2 + 1)
op -   rhs type BinaryOperator
(BinaryOperator '+'
  (DeclRefExpr 'int' Var  't2' )
  (IntegerLiteral 'int' 1)
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_chillBuilder::CreateIf()
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5 + 1] = (f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)])
sub 0  t2
sub 1  (t2 + n) + 1

subbing t2
for  chill_t5
subbing (t2 + n) + 1
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] = (f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t5' )
      (IntegerLiteral 'int' 1)
    )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'chill_t5' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] + f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (BinaryOperator '+'
        (DeclRefExpr 'int' Var  'chill_t5' )
        (IntegerLiteral 'int' 1)
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t5 in 
f1[chill_t6] * w[chill_t6 - (chill_t5 + 1)]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t5' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t6 - (chill_t5 + 1)
op -   rhs type BinaryOperator
(BinaryOperator '+'
  (DeclRefExpr 'int' Var  'chill_t5' )
  (IntegerLiteral 'int' 1)
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] = (f3[t2 + 1] + f1[chill_t6] * w[chill_t6 - (t2 + 1)])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  't2' )
      (IntegerLiteral 'int' 1)
    )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t6' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t6' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  't2' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] + f1[chill_t6] * w[chill_t6 - (t2 + 1)]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t6' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t6' )
      (BinaryOperator '+'
        (DeclRefExpr 'int' Var  't2' )
        (IntegerLiteral 'int' 1)
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t6 in 
f1[chill_t6] * w[chill_t6 - (t2 + 1)]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t6' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  't2' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
chill_t6 - (t2 + 1)
op -   rhs type BinaryOperator
(BinaryOperator '+'
  (DeclRefExpr 'int' Var  't2' )
  (IntegerLiteral 'int' 1)
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 3 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
3.14  3.14
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t5 + 1] = ((float) ((double) f3[chill_t5 + 1]) * 3.14)
sub 0  t2
sub 1  (t2 + n) + 1

subbing t2
for  chill_t5
subbing (t2 + n) + 1
for  chill_t6

SubABinaryOperator() subbing old variable chill_t5 in 
f3[chill_t5 + 1] = ((float) ((double) f3[chill_t5 + 1]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'chill_t5' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t5 in 
((double) f3[chill_t5 + 1]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
SubABinaryOperator() subbing old variable chill_t5 in 
chill_t5 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

sub in FL
SubABinaryOperator() subbing old variable chill_t6 in 
f3[t2 + 1] = ((float) ((double) f3[t2 + 1]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  't2' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t6 in 
((double) f3[t2 + 1]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
SubABinaryOperator() subbing old variable chill_t6 in 
t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

sub in FL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  { Sym=[over1] [t1,t2,t3,t4,t5] : 1 <= over1 }
output_guard()
GEQ
CG_chillBuilder::CreateIdent( over1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name over1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'over1' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateLE()
result =  ocg->CreateAnd(result, term);
CG_chillBuilder::CreateAnd()
CG_chillBuilder::CreateAnd()
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 3 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateTimes()
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )

CG_chillBuilder::CreateInductive()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t3] = (f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3])
sub 0  n
sub 1  t4

subbing n
for  chill_t3
subbing t4
for  chill_t4

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] = (f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t4' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t4' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t4' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t4' )
      (DeclRefExpr 'int' Var  'chill_t3' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
f1[chill_t4] * w[chill_t4 - chill_t3]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t4' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t4 - chill_t3
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t3' )

SubABinaryOperator() subbing old variable chill_t4 in 
f3[n] = (f3[n] + f1[chill_t4] * w[chill_t4 - n])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'n' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t4' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t4' )
        (DeclRefExpr 'int' Var  'n' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
f3[n] + f1[chill_t4] * w[chill_t4 - n]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t4' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t4' )
      (DeclRefExpr 'int' Var  'n' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
f1[chill_t4] * w[chill_t4 - n]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t4' )
    (DeclRefExpr 'int' Var  'n' )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
chill_t4 - n
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'n' )

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5] : 0 <= t2 }
output_guard()
GEQ
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateLE()
result =  ocg->CreateAnd(result, term);
CG_chillBuilder::CreateAnd()
CG_chillBuilder::CreateAnd()
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateIdent( n )
chillAST_VarDecl::chillAST_VarDecl( type int, name n, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'n' )
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateTimes()
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t3] = (f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3])
sub 0  n
sub 1  2 * n

subbing n
for  chill_t3
subbing 2 * n
for  chill_t4

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] = (f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t4' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t4' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] + f1[chill_t4] * w[chill_t4 - chill_t3]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t4' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t4' )
      (DeclRefExpr 'int' Var  'chill_t3' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
f1[chill_t4] * w[chill_t4 - chill_t3]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t4' )
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
chill_t4 - chill_t3
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t3' )

SubABinaryOperator() subbing old variable chill_t4 in 
f3[n] = (f3[n] + f1[chill_t4] * w[chill_t4 - n])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (f3) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f3' )
    (DeclRefExpr 'int' Var  'n' )
  )
  (BinaryOperator '*'
    (ArraySubscriptExpr (f1) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'f1' )
      (DeclRefExpr 'int' Var  'chill_t4' )
    )
    (ArraySubscriptExpr (w) 'float' rvalue
      (DeclRefExpr 'float *' ParmVar  'w' )
      (BinaryOperator '-'
        (DeclRefExpr 'int' Var  'chill_t4' )
        (DeclRefExpr 'int' Var  'n' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
f3[n] + f1[chill_t4] * w[chill_t4 - n]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (ArraySubscriptExpr (f1) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'f1' )
    (DeclRefExpr 'int' Var  'chill_t4' )
  )
  (ArraySubscriptExpr (w) 'float' rvalue
    (DeclRefExpr 'float *' ParmVar  'w' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t4' )
      (DeclRefExpr 'int' Var  'n' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
f1[chill_t4] * w[chill_t4 - n]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (w) 'float' rvalue
  (DeclRefExpr 'float *' ParmVar  'w' )
  (BinaryOperator '-'
    (DeclRefExpr 'int' Var  'chill_t4' )
    (DeclRefExpr 'int' Var  'n' )
  )
)

SubABinaryOperator() subbing old variable chill_t4 in 
chill_t4 - n
op -   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'n' )

CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
3.14  3.14
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = f3[chill_t3] = ((float) ((double) f3[chill_t3]) * 3.14)
sub 0  n
sub 1  2 * n

subbing n
for  chill_t3
subbing 2 * n
for  chill_t4

SubABinaryOperator() subbing old variable chill_t3 in 
f3[chill_t3] = ((float) ((double) f3[chill_t3]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'chill_t3' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t3 in 
((double) f3[chill_t3]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
SubABinaryOperator() subbing old variable chill_t4 in 
f3[n] = ((float) ((double) f3[n]) * 3.14)
op =   rhs type CStyleCastExpr
(CStyleCastExpr  (float) 
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (ArraySubscriptExpr (f3) 'float' rvalue
        (DeclRefExpr 'float *' ParmVar  'f3' )
        (DeclRefExpr 'int' Var  'n' )
      )
    )
    (FloatingLiteral 'double' 3.140000)
  )
)

SubCStyleCastExpr()  subexpr is type BinaryOperator
SubABinaryOperator() subbing old variable chill_t4 in 
((double) f3[n]) * 3.14
op *   rhs type FloatingLiteral
(FloatingLiteral 'double' 3.140000)

SubCStyleCastExpr()  subexpr is type ArraySubscriptExpr
sub in FL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_chillBuilder::CreateIf()
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_chillBuilder::CreateIf()
IR_roseCode::ReplaceCode( old, *repr)
old was
for (i = 0; i <= n; i++) {
  for (j = i; j <= (i + n); j++) 
    f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5]);
  f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14);
}


old parent was

{
int t4;
int t2;
int over1;
int i;
int j;
int k;
for (i = 1; i <= 14; i++) 
  x[i] = 1.0f;
for (i = 1; i <= 14; i += 3) 
  y[i] = 1.0f;
z[n + 1] = 1.0f;
z[(n + 1) + 3] = 1.0f;
z[(n + 1) + 6] = 1.0f;
z[(n + 1) + 9] = 1.0f;
z[(n + 1) + 12] = 1.0f;
z[(n + 1) + 15] = 1.0f;
z[(n + 1) + 18] = 1.0f;
for (i = 0; i <= n; i++) {
  for (j = i; j <= (i + n); j++) 
    f3[chill_t5] = (f3[chill_t5] + f1[chill_t6] * w[chill_t6 - chill_t5]);
  f3[chill_t5] = ((float) ((double) f3[chill_t5]) * 3.14);
}


}
inserting if (0 <= n)
  over1 = ((1 + n) % 2);

inserting for (t2 = 0; t2 <= (n - over1); t2 += 2) {
  if (1 <= n)
    f3[t2] = (f3[t2] + f1[t2] * w[t2 - t2]);
  for (t4 = (t2 + 1); t4 <= (t2 + n - 1); t4 += 1) {
    f3[t2] = (f3[t2] + f1[t4] * w[t4 - t2]);
    f3[t2 + 1] = (f3[t2 + 1] + f1[t4] * w[t4 - (t2 + 1)]);
  }
  f3[t2] = (f3[t2] + f1[t2 + n] * w[t2 + n - t2]);
  f3[t2] = ((float) ((double) f3[t2]) * 3.14);
  if ((t2 + 1) <= (t2 + n))
    f3[t2 + 1] = (f3[t2 + 1] + f1[t2 + n] * w[t2 + n - (t2 + 1)]);
  f3[t2 + 1] = (f3[t2 + 1] + f1[(t2 + n) + 1] * w[(t2 + n) + 1 - (t2 + 1)]);
  f3[t2 + 1] = ((float) ((double) f3[t2 + 1]) * 3.14);
}

inserting if (1 <= over1) {
  for (t4 = n; t4 <= (2 * n - 1); t4 += 1) 
    f3[n] = (f3[n] + f1[t4] * w[t4 - n]);
  if (0 <= n) {
    f3[n] = (f3[n] + f1[2 * n] * w[2 * n - n]);
    f3[n] = ((float) ((double) f3[n]) * 3.14);

  }
}

new parent2 is

{
int t4;
int t2;
int over1;
int i;
int j;
int k;
for (i = 1; i <= 14; i++) 
  x[i] = 1.0f;
;
for (i = 1; i <= 14; i += 3) 
  y[i] = 1.0f;
;
z[n + 1] = 1.0f;
z[(n + 1) + 3] = 1.0f;
z[(n + 1) + 6] = 1.0f;
z[(n + 1) + 9] = 1.0f;
z[(n + 1) + 12] = 1.0f;
z[(n + 1) + 15] = 1.0f;
z[(n + 1) + 18] = 1.0f;
over1 = 0;
if (0 <= n)
  over1 = ((1 + n) % 2);
;
for (t2 = 0; t2 <= (n - over1); t2 += 2) {
  if (1 <= n)
    f3[t2] = (f3[t2] + f1[t2] * w[t2 - t2]);
  for (t4 = (t2 + 1); t4 <= (t2 + n - 1); t4 += 1) {
    f3[t2] = (f3[t2] + f1[t4] * w[t4 - t2]);
    f3[t2 + 1] = (f3[t2 + 1] + f1[t4] * w[t4 - (t2 + 1)]);
  }
  f3[t2] = (f3[t2] + f1[t2 + n] * w[t2 + n - t2]);
  f3[t2] = ((float) ((double) f3[t2]) * 3.14);
  if ((t2 + 1) <= (t2 + n))
    f3[t2 + 1] = (f3[t2 + 1] + f1[t2 + n] * w[t2 + n - (t2 + 1)]);
  f3[t2 + 1] = (f3[t2 + 1] + f1[(t2 + n) + 1] * w[(t2 + n) + 1 - (t2 + 1)]);
  f3[t2 + 1] = ((float) ((double) f3[t2 + 1]) * 3.14);
}
;
if (1 <= over1) {
  for (t4 = n; t4 <= (2 * n - 1); t4 += 1) 
    f3[n] = (f3[n] + f1[t4] * w[t4 - n]);
  if (0 <= n) {
    f3[n] = (f3[n] + f1[2 * n] * w[2 * n - n]);
    f3[n] = ((float) ((double) f3[n]) * 3.14);

  }
};
}
deleting varDecl j
deleting varDecl k
// sourcefile has 2 children
they are
FunctionDecl
FunctionDecl
IR_chillCode::~IR_chillCode()
output happening as part of the destructor !!
