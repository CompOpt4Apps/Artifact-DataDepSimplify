source: jacobi2.c
procedure is main
format: rose
format rose
LOOP ':' NUMBER   parse the file because we haven't yet
CIT_ROSE
LOOP  ir_code = new IR_roseCode(source_filename, procedure_name);
IR_roseCode::IR_roseCode( file_name jacobi2.c, proc_name main )
IR_roseCode::IR_roseCode  actually parsing jacobi2.c using rose?
IR_roseCode::IR_roseCode()  project defined. file parsed by Rose
creating chillAST from Rose AST
ConvertXXXXVarDecl()
original vartype 'double [512UL]'
vartype = 'double '
arraypart = '[512]'
double  a   arraypart = '[512]'
2chillAST_VarDecl::chillAST_VarDecl( type double , name a, arraypart [512] )
2name a numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'double ' 'a' '[512]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'double [512UL]'
vartype = 'double '
arraypart = '[512]'
double  b   arraypart = '[512]'
2chillAST_VarDecl::chillAST_VarDecl( type double , name b, arraypart [512] )
2name b numdimensions 1
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'double ' 'b' '[512]'"  n_dim 1  )

ConvertXXXXVarDecl()
original vartype 'int'
vartype = 'int'
arraypart = ''
int t   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type int, name t, arraypart  )
2name t numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'int' 't' ''"  n_dim 0  )

ConvertXXXXVarDecl()
original vartype 'int'
vartype = 'int'
arraypart = ''
int i   arraypart = ''
2chillAST_VarDecl::chillAST_VarDecl( type int, name i, arraypart  )
2name i numdimensions 0
2chillAST_VarDecl::chillAST_VarDecl LEAVING
(VarDecl "'int' 'i' ''"  n_dim 0  )

ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'double [512]' Var  'b' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'double [512]' Var  'a' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'double [512]' Var  'a' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'double [512]' Var  'a' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'double [512]' Var  'a' )

ConvertRoseArrayRefExp()
converting base
ConvertXXXXXRefExpr()
ConvertXXXXXRefExpr()
ConvertRoseArrayRefExp, base (DeclRefExpr 'double [512]' Var  'b' )

chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE
unhandled top node 422/428 of type SgSymbolTable
unhandled top node 423/428 of type SgTypeTable
topnode 424 of 428, first == NULL??  blurb numeric_label
unhandled top node 425/428 of type Sg_File_Info
unhandled top node 426/428 of type Sg_File_Info
unhandled top node 427/428 of type SgSourceFile
found the procedure named main
local Function Definition 0x2cc5580

int main(  )
{
  double  a[512];
  double  b[512];
  int t;
  int i;
  for (t = 1; t <= 100; t++) {
    for (i = 2; i <= (512 - 1); i++) 
      b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
    for (i = 2; i <= (512 - 1); i++) 
      a[i] = b[i];
  }
  return(0);

}


printing whole file


// sourcefile has 1 children
they are
FunctionDecl

// this source derived from CHILL AST originally from file 'jacobi2.c' as parsed by frontend compiler rose


int main(  )
{
  double  a[512];
  double  b[512];
  int t;
  int i;
  for (t = 1; t <= 100; t++) {
    for (i = 2; i <= (512 - 1); i++) 
      b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
    for (i = 2; i <= (512 - 1); i++) 
      a[i] = b[i];
  }
  return(0);

}

//CHILL AST originally from file 'jacobi2.c'

(FunctionDecl int main()
  (CompoundStmt 
    (VarDecl "'double ' 'a' '[512]'"  n_dim 1  )
    (VarDecl "'double ' 'b' '[512]'"  n_dim 1  )
    (VarDecl "'int' 't' ''"  n_dim 0  )
    (VarDecl "'int' 'i' ''"  n_dim 0  )
    (ForStmt 
      (BinaryOperator '='
        (DeclRefExpr 'int' Var  't' )
        (IntegerLiteral 'int' 1)
      )
      (BinaryOperator '<='
        (DeclRefExpr 'int' Var  't' )
        (IntegerLiteral 'int' 100)
      )
      (UnaryOperator postfix ++
        (DeclRefExpr 'int' Var  't' )
      )
      (CompoundStmt 
        (ForStmt 
          (BinaryOperator '='
            (DeclRefExpr 'int' Var  'i' )
            (IntegerLiteral 'int' 2)
          )
          (BinaryOperator '<='
            (DeclRefExpr 'int' Var  'i' )
            (BinaryOperator '-'
              (IntegerLiteral 'int' 512)
              (IntegerLiteral 'int' 1)
            )
          )
          (UnaryOperator postfix ++
            (DeclRefExpr 'int' Var  'i' )
          )
          (CompoundStmt 
            (BinaryOperator '='
              (ArraySubscriptExpr (b) 'double' lvalue
                (DeclRefExpr 'double [512]' Var  'b' )
                (DeclRefExpr 'int' Var  'i' )
              )
              (BinaryOperator '+'
                (BinaryOperator '*'
                  (CStyleCastExpr  (double) 
                    (FloatingLiteral 'double' 0.250000)
                  )
                  (BinaryOperator '+'
                    (ArraySubscriptExpr (a) 'double' rvalue
                      (DeclRefExpr 'double [512]' Var  'a' )
                      (BinaryOperator '-'
                        (DeclRefExpr 'int' Var  'i' )
                        (IntegerLiteral 'int' 1)
                      )
                    )
                    (ArraySubscriptExpr (a) 'double' rvalue
                      (DeclRefExpr 'double [512]' Var  'a' )
                      (BinaryOperator '+'
                        (DeclRefExpr 'int' Var  'i' )
                        (IntegerLiteral 'int' 1)
                      )
                    )
                  )
                )
                (BinaryOperator '*'
                  (CStyleCastExpr  (double) 
                    (FloatingLiteral 'double' 0.500000)
                  )
                  (ArraySubscriptExpr (a) 'double' rvalue
                    (DeclRefExpr 'double [512]' Var  'a' )
                    (DeclRefExpr 'int' Var  'i' )
                  )
                )
              )
            )
          )
        )
        (ForStmt 
          (BinaryOperator '='
            (DeclRefExpr 'int' Var  'i' )
            (IntegerLiteral 'int' 2)
          )
          (BinaryOperator '<='
            (DeclRefExpr 'int' Var  'i' )
            (BinaryOperator '-'
              (IntegerLiteral 'int' 512)
              (IntegerLiteral 'int' 1)
            )
          )
          (UnaryOperator postfix ++
            (DeclRefExpr 'int' Var  'i' )
          )
          (CompoundStmt 
            (BinaryOperator '='
              (ArraySubscriptExpr (a) 'double' lvalue
                (DeclRefExpr 'double [512]' Var  'a' )
                (DeclRefExpr 'int' Var  'i' )
              )
              (ArraySubscriptExpr (b) 'double' rvalue
                (DeclRefExpr 'double [512]' Var  'b' )
                (DeclRefExpr 'int' Var  'i' )
              )
            )
          )
        )
      )
    )
    (ReturnStmt
      (IntegerLiteral 'int' 0)
    )
  )
)
need to create symbol tables?
LOOP RETURN ir_code = new IR_roseCode(source_filename, procedure_name);
yyparse  block = ir_code->GetCode();
IR_roseCode::GetCode()
chillfunc 0x2cc5580
chillast body of func is 0x2cc5630
making a new IR_roseBlock with chillAST

int main(  )
{
  double  a[512];
  double  b[512];
  int t;
  int i;
  for (t = 1; t <= 100; t++) {
    for (i = 2; i <= (512 - 1); i++) 
      b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
    for (i = 2; i <= (512 - 1); i++) 
      a[i] = b[i];
  }
  return(0);

}

in yyparse, IR_Block block 0x2cc22a0

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type FunctionDecl

int main(  )
{
  double  a[512];
  double  b[512];
  int t;
  int i;
  for (t = 1; t <= 100; t++) {
    for (i = 2; i <= (512 - 1); i++) 
      b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
    for (i = 2; i <= (512 - 1); i++) 
      a[i] = b[i];
  }
  return(0);

}



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
basic block has 6 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/6 is of type VarDecl
straight line code adding to basicblock that had 0
child 0/6 = double  a[512]
child 0 is part of a basic block
now basicblock has 1 statements
child 1/6 is of type VarDecl
straight line code adding to basicblock that had 1
child 1/6 = double  b[512]
child 1 is part of a basic block
now basicblock has 2 statements
child 2/6 is of type VarDecl
straight line code adding to basicblock that had 2
child 2/6 = int t
child 2 is part of a basic block
now basicblock has 3 statements
child 3/6 is of type VarDecl
straight line code adding to basicblock that had 3
child 3/6 = int i
child 3 is part of a basic block
now basicblock has 4 statements
child 4/6 is of type ForStmt
found a For statement (Loop) at 4/6 within a Basic Block
pushing a run of statements 0 to 3 as a block
making a new IR_roseBlock with NO chillAST (nil)
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (t = 1; t <= 100; t++) {
  for (i = 2; i <= (512 - 1); i++) 
    b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
  for (i = 2; i <= (512 - 1); i++) 
    a[i] = b[i];
}

IR_roseLoop::IR_roseLoop()    chillbody
body is:
for (i = 2; i <= (512 - 1); i++) 
  b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
for (i = 2; i <= (512 - 1); i++) 
  a[i] = b[i];


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
child 5/6 is of type ReturnStmt
straight line code adding to basicblock that had 0
child 5/6 = return(0)
child 5 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 6
end of body ends the run of 1 statements in the Basic Block

*** block is a compoundstatement or a function decl  END 
returning vector of 3 controls
(parser.yy) I found 1 loops in the procedure

parse.yy  L 505 making a new myloop loop num start 0

***                                                   ROSE (parser.yy) making a new myloop

Loop::Loop(const IR_Control *control)
control type is 0   IR_CONTROL_LOOP
in Loop::Loop, calling  build_ir_tree()

loop.cc, Loop::Loop() about to clone control
IR_roseLoop::clone()
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (t = 1; t <= 100; t++) {
  for (i = 2; i <= (512 - 1); i++) 
    b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
  for (i = 2; i <= (512 - 1); i++) 
    a[i] = b[i];
}

IR_roseLoop::IR_roseLoop()    chillbody
body is:
for (i = 2; i <= (512 - 1); i++) 
  b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
for (i = 2; i <= (512 - 1); i++) 
  a[i] = b[i];


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
case IR_CONTROL_LOOP
recursing. build_ir_tree() of CONTROL_LOOP creating children  L122
IR_roseLoop::body()
making a new IR_roseBlock with chillAST
for (i = 2; i <= (512 - 1); i++) 
  b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
for (i = 2; i <= (512 - 1); i++) 
  a[i] = b[i];

irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type CompoundStmt
for (i = 2; i <= (512 - 1); i++) 
  b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);
for (i = 2; i <= (512 - 1); i++) 
  a[i] = b[i];



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
found a top level Basic Block Compound Statement
basic block has 2 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/2 is of type ForStmt
found a For statement (Loop) at 0/2 within a Basic Block
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = 2; i <= (512 - 1); i++) 
  b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);

IR_roseLoop::IR_roseLoop()    chillbody
body is:
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
child 1/2 is of type ForStmt
found a For statement (Loop) at 1/2 within a Basic Block
IR_roseLoop::IR_roseLoop(ir_, chillforstmt)
loop is:
for (i = 2; i <= (512 - 1); i++) 
  a[i] = b[i];

IR_roseLoop::IR_roseLoop()    chillbody
body is:
a[i] = b[i];


chillbody of type CompoundStmt
IR_roseLoop::IR_roseLoop() DONE
ns 0  numchildren 2

*** block is a compoundstatement or a function decl  END 
returning vector of 2 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 2  (NONZERO)
controls[0] is IR_CONTROL_LOOP
IR_roseLoop::body()
making a new IR_roseBlock with chillAST
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);

irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type CompoundStmt
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]);



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
found a top level Basic Block Compound Statement
basic block has 1 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/1 is of type BinaryOperator
straight line code adding to basicblock that had 0
child 0/1 = b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
child 0 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 1
NOT sending straightline run of statements, because it would be the entire block. There are no control statements in the block

*** block is a compoundstatement or a function decl  END 
returning vector of 0 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 0
build_ir_tree()  vector result has 1 parts
controls[1] is IR_CONTROL_LOOP
IR_roseLoop::body()
making a new IR_roseBlock with chillAST
a[i] = b[i];

irtools.cc, build_ir_tree( control, parent)   building a CHILL IR tree 
irtools.cc L31   case IR_CONTROL_BLOCK

IR_roseCode::FindOneLevelControlStructure()
basic block is:
block ast of type CompoundStmt
a[i] = b[i];



*** block is a compoundstatement or a function decl or NULL

*** block is a compoundstatement or a function decl
found a top level Basic Block Compound Statement
basic block has 1 statements
making a new IR_roseBlock with NO chillAST (nil)
child 0/1 is of type BinaryOperator
straight line code adding to basicblock that had 0
child 0/1 = a[i] = b[i]
child 0 is part of a basic block
now basicblock has 1 statements
ns 1  numchildren 1
NOT sending straightline run of statements, because it would be the entire block. There are no control statements in the block

*** block is a compoundstatement or a function decl  END 
returning vector of 0 controls
irtools.cc BACK FROM FindOneLevelControlStructure()
controls.size() == 0
build_ir_tree()  vector result has 1 parts
build_ir_tree()  vector result has 2 parts
recursing. build_ir_tree() of CONTROL_LOOP creating children DONE
build_ir_tree()  vector result has 1 parts
in Loop::Loop. ir_tree has 1 parts
before init_loops, 0 freevar
dammit 0

                                                  Loop::init_loop()
extract
nesting level stmt size = 2
2 statements?
i 0
stmt_nesting_level[0] = 2
i 1
stmt_nesting_level[1] = 2
in init_loop, made 2 stmts
max nesting level 2 at location 0
itn = stmt[0]
parent
IR_CONTROL_LOOP  cur_dim 1
making scalar symbol i
index[1] = 'i'
parent
IR_CONTROL_LOOP  cur_dim 0
making scalar symbol t
index[0] = 't'
align loops by names,

set relation variable names                      ****
Relation r(2)
it's a loop.  temp_depth 1
r.name_set_var( 2, i )
it's a loop.  temp_depth 0
r.name_set_var( 1, t )
Relation r   {[t,i] : TRUE }
extract information from loop/if structures
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
2

exp2formula()
{[t,i] : TRUE }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
512 - 1

IR_roseLoop::stop_cond()
exp2formula()
{[t,i] : 2 <= i }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_MINUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] : 2 <= i and exists ( e1,e2 : ( i+e2 <= e1 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] : 2 <= i and exists ( e1,e2 : ( 512 = e1 && i+e2 <= e1 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
1

exp2formula()
{[t,i] : 2 <= i and exists ( e1,e2 : ( 512 = e1 && 1 = e2 && i+e2 <= e1 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
100

IR_roseLoop::stop_cond()
exp2formula()
{[t,i] : 2 <= i && 1 <= t and exists ( e1,e2 : ( 512 = e1 && 1 = e2 && i+e2 <= e1 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
add information for missing loops   n_dim(2)
loop.cc L441 insert the statement
loop.cc before extract
IR_roseBlock::extract()
block has chillAST of type CompoundStmt
block has 0 exploded statements
IR_roseBlock::extract() LEAVING
code =  ocg->CreateSubstitutedStmt(...)


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
0 vars and 0 substitutions
1 nodes in old code. was:
stmt(0) = b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])

nosubs old code was:
stmt = b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
stmt
for int i < n_dim(2)
whew
max nesting level 2 at location 1
align loops by names,
IR_roseBlock::extract()
block has chillAST of type CompoundStmt
block has 0 exploded statements
IR_roseBlock::extract() LEAVING
CG_chillBuilder::CreateIdent( i )
chillAST_VarDecl::chillAST_VarDecl( type int, name i, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'i' )
making scalar symbol i


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
1 vars and 1 substitutions
1 nodes in old code. was:
stmt(0) = a[i] = b[i]
sub 0  i

subbing i
for  i

SubABinaryOperator() subbing old variable i in 
a[i] = b[i]
op =   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (b) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'b' )
  (DeclRefExpr 'int' Var  'i' )
)


set relation variable names                      ****
Relation r(2)
it's a loop.  temp_depth 1
r.name_set_var( 2, i )
it's a loop.  temp_depth 0
r.name_set_var( 1, t )
Relation r   {[t,i] : TRUE }
extract information from loop/if structures
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
2

exp2formula()
{[t,i] : TRUE }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
512 - 1

IR_roseLoop::stop_cond()
exp2formula()
{[t,i] : 2 <= i }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_MINUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] : 2 <= i and exists ( e3,e4 : ( i+e4 <= e3 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] : 2 <= i and exists ( e3,e4 : ( 512 = e3 && i+e4 <= e3 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
IR_CONTROL_LOOP
IR_roseLoop::lower_bound()
loop.cc, got the lower bound. it is:
1

exp2formula()
{[t,i] : 2 <= i and exists ( e3,e4 : ( 512 = e3 && 1 = e4 && i+e4 <= e3 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::upper_bound()
loop.cc, got the upper bound. it is:
100

IR_roseLoop::stop_cond()
exp2formula()
{[t,i] : 2 <= i && 1 <= t and exists ( e3,e4 : ( 512 = e3 && 1 = e4 && i+e4 <= e3 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
IR_roseLoop::lower_bound()
IR_roseCode::QueryExpOperation()
abs(c)
add information for missing loops   n_dim(2)
loop.cc L441 insert the statement
loop.cc before extract
IR_roseBlock::extract()
block has chillAST of type CompoundStmt
block has 0 exploded statements
IR_roseBlock::extract() LEAVING
code =  ocg->CreateSubstitutedStmt(...)


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
0 vars and 0 substitutions
1 nodes in old code. was:
stmt(0) = a[i] = b[i]

nosubs old code was:
stmt = a[i] = b[i]
stmt
for int i < n_dim(2)
whew
                                        loop.cc   Loop::init_loop() END

after init_loops, 0 freevar
loop.cc 2 statements
this really REALLY needs some comments
i 0
j 0

irtools.cc test_data_dependences()  0 freevars
repr1   b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
repr2   b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
index 0 t
index 1 i
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
repr1 == repr2
repr1->dump()
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for b
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for a
b
a
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for a
b
a
a
b
a
a
b
a
a
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for a
b
a
a
a
b
a
a
a
b
a
a
a
4 total refs 
ref[0] b is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'b' write 1
ref[1] a is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 0
ref[2] a is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 0
ref[3] a is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 0
access of size 4
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
WRITE  array access 0 = b
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
       array access 1 = a
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
       array access 2 = a
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
       array access 3 = a
that was the list


before mapRefstoStatements()
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
 IR_roseCode::FromSameStmt()
b[i]
b[i]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
b[i]
a[i - 1]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
b[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i - 1]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i - 1] + a[i + 1]
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
a[i - 1] + a[i + 1]
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
b[i]
a[i + 1]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
b[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i + 1]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i - 1] + a[i + 1]
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
a[i - 1] + a[i + 1]
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
b[i]
a[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
b[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
((double) 0.5) * a[i]
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
((double) 0.5) * a[i]
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i - 1]
a[i - 1]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i - 1]
a[i + 1]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i - 1]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i - 1] + a[i + 1]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i + 1]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i - 1] + a[i + 1]
a[i - 1] + a[i + 1]
a[i - 1] + a[i + 1]
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i - 1]
a[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i - 1]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i - 1] + a[i + 1]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
((double) 0.5) * a[i]
a[i - 1] + a[i + 1]
((double) 0.5) * a[i]
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i + 1]
a[i + 1]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i + 1]
a[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i + 1]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i - 1] + a[i + 1]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
((double) 0.5) * a[i]
a[i - 1] + a[i + 1]
((double) 0.5) * a[i]
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i]
a[i]
trivially true because they are exactly the same statement
after mapRefstoStatements()

i 0
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
sym_a = b
j 0
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
sym_b = b
irtools.cc ij 0 0
*sym_a == *sym_b
0 a->is_write()
0 b->is_write()

irtools.cc ij 0 0   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
0 freevars
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[t,i] -> [t',i'] : exists ( e5,e6 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[t,i] -> [t',i'] : exists ( e5,e6 : ( i = e5 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::n_dim() 1
r    {[t,i] -> [t',i'] : exists ( e5,e6 : ( i = e5 && i' = e6 && e6 = e5 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
leaving arrays2relation
r    {[t,i] -> [t',i'] : exists ( e5,e6 : ( i = e5 && i' = e6 && e6 = e5 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
1
relation2dependences()
{[In_1,In_2] : exists ( t,i,t',i' : ( i' = i && t' = t+In_1 && i' = i+In_2 && 2 <= i <= 511 && 1 <= t <= 100 && 1 <= t' <= 100 )) }
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t+In_1 && i' = i+In_2 && 1 <= t < t' <= 100 && 2 <= i' <= 511 && t <= 100 && 1 <= t' )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
symbol b  ADDING A DEPENDENCE OF TYPE DEP_W2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (b)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol b

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t && t' = t+In_1 && i' = i+In_2 && 2 <= i' <= 511 && 1 <= t <= 100 )) }

dv created in if                                         ***
leaving relation2dependences, 1 and 0 dependences
dependences1[0]: symbol b
symbol b  HAS A left  DEPENDENCE OF TYPE DEP_W2W
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)

irtools.cc ij 0 0 dv.first 1   dv.second 0
2IR_roseArraySymbol::IR_roseArraySymbol (b)
34IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
j 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 0 1
*sym_a NOT == *sym_b
0 a->is_write()
1 b->is_NOT_write()
j 2
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 0 2
*sym_a NOT == *sym_b
0 a->is_write()
2 b->is_NOT_write()
j 3
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 0 3
*sym_a NOT == *sym_b
0 a->is_write()
3 b->is_NOT_write()
i 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_a = a
j 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 1 1
*sym_a == *sym_b
1 a->is_NOT_write()
1 b->is_NOT_write()
j 2
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 1 2
*sym_a == *sym_b
1 a->is_NOT_write()
2 b->is_NOT_write()
j 3
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 1 3
*sym_a == *sym_b
1 a->is_NOT_write()
3 b->is_NOT_write()
i 2
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_a = a
j 2
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 2 2
*sym_a == *sym_b
2 a->is_NOT_write()
2 b->is_NOT_write()
j 3
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 2 3
*sym_a == *sym_b
2 a->is_NOT_write()
3 b->is_NOT_write()
i 3
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_a = a
j 3
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 3 3
*sym_a == *sym_b
3 a->is_NOT_write()
3 b->is_NOT_write()
LEAVING test_data_dependences()  first size 2    second size 0

dv.first.size() 2
k1 0
IR_roseArraySymbol::IR_roseArraySymbol (b)
k1 1
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
j 1

irtools.cc test_data_dependences()  0 freevars
repr1   b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
repr2   a[i] = b[i]
index 0 t
index 1 i
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }

repr1 != repr2
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for b
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for a
b
a
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for a
b
a
a
b
a
a
b
a
a
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for a
b
a
a
a
b
a
a
a
b
a
a
a
4 total refs 
ref[0] b is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'b' write 1
ref[1] a is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 0
ref[2] a is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 0
ref[3] a is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 0
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = a[i] = b[i]
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for a
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for b
a
b
2 total refs 
ref[0] a is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 1
ref[1] b is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'b' write 0
i 0
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
arrays2relation()
0 freevars
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[t,i] -> [t',i'] : exists ( e7,e8 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[t,i] -> [t',i'] : exists ( e7,e8 : ( i = e7 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::n_dim() 1
r    {[t,i] -> [t',i'] : exists ( e7,e8 : ( i = e7 && i' = e8 && e8 = e7 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
leaving arrays2relation
relation2dependences()
{[In_1,In_2] : exists ( t,i,t',i' : ( i' = i && t' = t+In_1 && i' = i+In_2 && 2 <= i <= 511 && 1 <= t <= 100 && 1 <= t' <= 100 )) }
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t+In_1 && i' = i+In_2 && 1 <= t < t' <= 100 && 2 <= i' <= 511 && t <= 100 && 1 <= t' )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
symbol b  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (b)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol b

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t+In_1 && i' = i+In_2 && 1, t'+1 <= t <= 100 && 2 <= i' <= 511 && 1 <= t' <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
symbol b  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences2
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (b)
DONE pushing dv
now 1 dependences2
dependences2[0]: symbol b

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t && t' = t+In_1 && i' = i+In_2 && 2 <= i' <= 511 && 1 <= t <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
symbol b  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol b
dependences1[1]: symbol b

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 1 dependences
dependences1[0]: symbol b
symbol b  HAS A left  DEPENDENCE OF TYPE DEP_W2R
dependences1[1]: symbol b
symbol b  HAS A left  DEPENDENCE OF TYPE DEP_W2R
symbol b  HAS A right DEPENDENCE OF TYPE DEP_R2W
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
i 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
arrays2relation()
0 freevars
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[t,i] -> [t',i'] : exists ( e9,e10 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_MINUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] -> [t',i'] : exists ( e9,e10 : ( exists ( e11,e12 : ( e11 = e9+e12 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[t,i] -> [t',i'] : exists ( e9,e10 : ( exists ( e11,e12 : ( e11 = e9+e12 && i = e11 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] -> [t',i'] : exists ( e9,e10 : ( exists ( e11,e12 : ( e11 = e9+e12 && i = e11 && 1 = e12 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
r    {[t,i] -> [t',i'] : exists ( e9,e10 : ( exists ( e11,e12 : ( e11 = e9+e12 && i = e11 && 1 = e12 )) and i' = e10 && e10 = e9 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
leaving arrays2relation
relation2dependences()
{[In_1,In_2] : exists ( t,i,t',i' : ( 1+i' = i && t' = t+In_1 && i' = i+In_2 && 3 <= i <= 511 && 1 <= t <= 100 && 1 <= t' <= 100 )) }
{[In_1,In_2] : exists ( t,i,t',i' : ( i = 1+i' && t' = t+In_1 && i' = i+In_2 && 1 <= t < t' <= 100 && 2 <= i' <= 510 && t <= 100 && 1 <= t' )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = 1+i' && t' = t+In_1 && i' = i+In_2 && 1, t'+1 <= t <= 100 && 2 <= i' <= 510 && 1 <= t' <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences2
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences2
dependences2[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = 1+i' && t' = t && t' = t+In_1 && i' = i+In_2 && 2 <= i' <= 510 && 1 <= t <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences2
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 2 dependences2
dependences2[0]: symbol a
dependences2[1]: symbol a

dv goes out of scope                                      ***
leaving relation2dependences, 1 and 2 dependences
dependences1[0]: symbol a
symbol a  HAS A left  DEPENDENCE OF TYPE DEP_R2W
symbol a  HAS A right DEPENDENCE OF TYPE DEP_W2R
symbol a  HAS A right DEPENDENCE OF TYPE DEP_W2R
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
i 2
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
arrays2relation()
0 freevars
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[t,i] -> [t',i'] : exists ( e13,e14 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_PLUS
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] -> [t',i'] : exists ( e13,e14 : ( exists ( e15,e16 : ( e15+e16 = e13 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[t,i] -> [t',i'] : exists ( e13,e14 : ( exists ( e15,e16 : ( e15+e16 = e13 && i = e15 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
IR_OP_CONSTANT
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
exp2formula()
{[t,i] -> [t',i'] : exists ( e13,e14 : ( exists ( e15,e16 : ( e15+e16 = e13 && i = e15 && 1 = e16 )) )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
r    {[t,i] -> [t',i'] : exists ( e13,e14 : ( exists ( e15,e16 : ( e15+e16 = e13 && i = e15 && 1 = e16 )) and i' = e14 && e14 = e13 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
leaving arrays2relation
relation2dependences()
{[In_1,In_2] : exists ( t,i,t',i' : ( i' = 1+i && t' = t+In_1 && i' = i+In_2 && 2 <= i <= 510 && 1 <= t <= 100 && 1 <= t' <= 100 )) }
{[In_1,In_2] : exists ( t,i,t',i' : ( 1+i = i' && t' = t+In_1 && i' = i+In_2 && 1 <= t < t' <= 100 && 3 <= i' <= 511 && t <= 100 && 1 <= t' )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( 1+i = i' && t' = t+In_1 && i' = i+In_2 && 1, t'+1 <= t <= 100 && 3 <= i' <= 511 && 1 <= t' <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences2
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences2
dependences2[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( 1+i = i' && t' = t && t' = t+In_1 && i' = i+In_2 && 3 <= i' <= 511 && 1 <= t <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol a
dependences1[1]: symbol a

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 1 dependences
dependences1[0]: symbol a
symbol a  HAS A left  DEPENDENCE OF TYPE DEP_R2W
dependences1[1]: symbol a
symbol a  HAS A left  DEPENDENCE OF TYPE DEP_R2W
symbol a  HAS A right DEPENDENCE OF TYPE DEP_W2R
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
i 3
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
arrays2relation()
0 freevars
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[t,i] -> [t',i'] : exists ( e17,e18 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[t,i] -> [t',i'] : exists ( e17,e18 : ( i = e17 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
r    {[t,i] -> [t',i'] : exists ( e17,e18 : ( i = e17 && i' = e18 && e18 = e17 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
leaving arrays2relation
relation2dependences()
{[In_1,In_2] : exists ( t,i,t',i' : ( i' = i && t' = t+In_1 && i' = i+In_2 && 2 <= i <= 511 && 1 <= t <= 100 && 1 <= t' <= 100 )) }
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t+In_1 && i' = i+In_2 && 1 <= t < t' <= 100 && 2 <= i' <= 511 && t <= 100 && 1 <= t' )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t+In_1 && i' = i+In_2 && 1, t'+1 <= t <= 100 && 2 <= i' <= 511 && 1 <= t' <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_W2R to dependences2
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences2
dependences2[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t && t' = t+In_1 && i' = i+In_2 && 2 <= i' <= 511 && 1 <= t <= 100 )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_R2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 2 dependences1
dependences1[0]: symbol a
dependences1[1]: symbol a

dv goes out of scope                                      ***
leaving relation2dependences, 2 and 1 dependences
dependences1[0]: symbol a
symbol a  HAS A left  DEPENDENCE OF TYPE DEP_R2W
dependences1[1]: symbol a
symbol a  HAS A left  DEPENDENCE OF TYPE DEP_R2W
symbol a  HAS A right DEPENDENCE OF TYPE DEP_W2R
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
LEAVING test_data_dependences()  first size 7    second size 5

dv.first.size() 7
k1 0
IR_roseArraySymbol::IR_roseArraySymbol (b)
k1 1
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
k1 2
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
k1 3
IR_roseArraySymbol::IR_roseArraySymbol (a)
k1 4
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
k1 5
IR_roseArraySymbol::IR_roseArraySymbol (a)
k1 6
IR_roseArraySymbol::IR_roseArraySymbol (a)
k2 0
IR_roseArraySymbol::IR_roseArraySymbol (b)
k2 1
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
k2 2
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
k2 3
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
k2 4
IR_roseArraySymbol::IR_roseArraySymbol (a)
i 1
j 1

irtools.cc test_data_dependences()  0 freevars
repr1   a[i] = b[i]
repr2   a[i] = b[i]
index 0 t
index 1 i
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
repr1 == repr2
repr1->dump()
a[i] = b[i]
IR_roseCode::FindArrayRef()
there are 1 chill statements in this repr

chillstatement 0 = a[i] = b[i]
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 1 for a
chillAST_ArraySubscriptExpr::gatherArrayRefs setting imwrittento 0 for b
a
b
2 total refs 
ref[0] a is writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'a' write 1
ref[1] b is NOT writtento
IR_XXXXArrayRef::IR_XXXXArrayRef() 'b' write 0
access of size 2
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
WRITE  array access 0 = a
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
       array access 1 = b
that was the list


before mapRefstoStatements()
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
 IR_roseCode::FromSameStmt()
a[i]
a[i]
trivially true because they are exactly the same statement
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
 IR_roseCode::FromSameStmt()
a[i]
b[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
a[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i] = b[i]
chillAST_node::getEnclosingStatement( level 0 ) node type ArraySubscriptExpr
b[i]
chillAST_node::getEnclosingStatement( level 1 ) node type BinaryOperator
a[i] = b[i]
a[i] = b[i]
a[i] = b[i]
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
 IR_roseCode::FromSameStmt()
b[i]
b[i]
trivially true because they are exactly the same statement
after mapRefstoStatements()

i 0
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_a = a
j 0
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
sym_b = a
irtools.cc ij 0 0
*sym_a == *sym_b
0 a->is_write()
0 b->is_write()

irtools.cc ij 0 0   SYMBOL A == SYMBOL B and one is a write
arrays2relation()
0 freevars
IS1  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
IS2  {[t,i] : 2 <= i <= 511 && 1 <= t <= 100 }
r    {[In_1,In_2] -> [Out_1,Out_2] : FALSE }
omegatools.cc sym_src
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
omegatools.cc  (*sym_src != *sym_dst) FALSE
f_root
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
omegatools.cc ref_src->n_dim() 1
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
arrays2 i 0
IR_roseArrayRef::index( 0 )  
IR_roseArrayRef::index( 0 )  
IR_roseCode::QueryExpOperation()
IR_roseCode::QueryExpOperation()
exp2formula()
{[t,i] -> [t',i'] : exists ( e19,e20 : ( TRUE )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
exp2formula()
{[t,i] -> [t',i'] : exists ( e19,e20 : ( i = e19 )) }

IR_roseCode::QueryExpOperation()
QueryExpOperation() done
omegatools.cc IR_OP_VARIABLE
repr  i
IR_roseCode::QueryExpOperAND()
IR_roseCode::QueryExpOperand() DONE
v     i
making scalar symbol i
s i
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::n_dim() 1
r    {[t,i] -> [t',i'] : exists ( e19,e20 : ( i = e19 && i' = e20 && e20 = e19 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
leaving arrays2relation
r    {[t,i] -> [t',i'] : exists ( e19,e20 : ( i = e19 && i' = e20 && e20 = e19 )) and 2 <= i <= 511 && 1 <= t <= 100 and 2 <= i' <= 511 && 1 <= t' <= 100 }
1
relation2dependences()
{[In_1,In_2] : exists ( t,i,t',i' : ( i' = i && t' = t+In_1 && i' = i+In_2 && 2 <= i <= 511 && 1 <= t <= 100 && 1 <= t' <= 100 )) }
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t+In_1 && i' = i+In_2 && 1 <= t < t' <= 100 && 2 <= i' <= 511 && t <= 100 && 1 <= t' )) }

dv created in if                                         ***
omegatools.cc calling ref_src->symbol();
IR_roseArrayRef::symbol()
base a
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( a )
IR_roseArraySymbol::IR_roseArraySymbol (a)
symbol a  ADDING A DEPENDENCE OF TYPE DEP_W2W to dependences1
pushing dv
IR_roseArraySymbol::IR_roseArraySymbol (a)
DONE pushing dv
now 1 dependences1
dependences1[0]: symbol a

dv goes out of scope                                      ***
{[In_1,In_2] : exists ( t,i,t',i' : ( i = i' && t' = t && t' = t+In_1 && i' = i+In_2 && 2 <= i' <= 511 && 1 <= t <= 100 )) }

dv created in if                                         ***
leaving relation2dependences, 1 and 0 dependences
dependences1[0]: symbol a
symbol a  HAS A left  DEPENDENCE OF TYPE DEP_W2W
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)

irtools.cc ij 0 0 dv.first 1   dv.second 0
2IR_roseArraySymbol::IR_roseArraySymbol (a)
34IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
j 1
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
sym_b = b
irtools.cc ij 0 1
*sym_a NOT == *sym_b
0 a->is_write()
1 b->is_NOT_write()
i 1
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
sym_a = b
j 1
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArrayRef::symbol()
base b
IR_roseArrayRef::symbol() returning new IR_roseArraySymbol( b )
IR_roseArraySymbol::IR_roseArraySymbol (b)
sym_b = b
irtools.cc ij 1 1
*sym_a == *sym_b
1 a->is_NOT_write()
1 b->is_NOT_write()
LEAVING test_data_dependences()  first size 2    second size 0

dv.first.size() 2
k1 0
IR_roseArraySymbol::IR_roseArraySymbol (a)
k1 1
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)


*** LOTS OF REDUCTIONS ***


i range 2
i 0
dep.hasEdge(0, 0)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
tdv size 2
ij 0 0
ij 0 1
i 1
dep.hasEdge(1, 1)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
tdv size 2
ij 1 0
ij 1 1
loop.cc reducCand.size() 0
loop.cc canReduce.size() 0
init dumb transformation relations
                                                  at bottom of Loop::Loop, printCode
dependence graph:
1->1: b:output(1~99, 0) b:output(1~99, 0)
1->2: b:flow(1~99, 0) b:flow(0, 0) a:anti(1~99, -1) a:anti(1~99, 1) a:anti(0, 1) a:anti(1~99, 0) a:anti(0, 0) a:_quasianti(0, -1)
2->1: b:anti(1~99, 0) a:flow(1~99, 1) a:flow(1~99, -1) a:flow(1~99, 0)
2->2: a:output(1~99, 0) a:output(1~99, 0)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
loop.cc apply_xform( set )

{[t,i] -> [chill_t1,chill_t2] : t = chill_t1 && i = chill_t2 }
FIX THIS rose in generic loop.cc
loop vars 0 t
loop vars 1 i
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t1' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t2' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
2 uninterpreted symbols
loop vars 0 t
loop vars 1 i
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
sub 0  chill_t1
sub 1  chill_t2

subbing chill_t1
for  t
subbing chill_t2
for  i

SubABinaryOperator() subbing old variable t in 
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.250000)
    )
    (BinaryOperator '+'
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '-'
          (DeclRefExpr 'int' Var  'i' )
          (IntegerLiteral 'int' 1)
        )
      )
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'i' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.500000)
    )
    (ArraySubscriptExpr (a) 'double' rvalue
      (DeclRefExpr 'double [512]' Var  'a' )
      (DeclRefExpr 'int' Var  'i' )
    )
  )
)

SubABinaryOperator() subbing old variable t in 
((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (CStyleCastExpr  (double) 
    (FloatingLiteral 'double' 0.500000)
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (DeclRefExpr 'int' Var  'i' )
  )
)

SubABinaryOperator() subbing old variable t in 
((double) 0.25) * (a[i - 1] + a[i + 1])
op *   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'i' )
      (IntegerLiteral 'int' 1)
    )
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'i' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable t in 
a[i - 1] + a[i + 1]
op +   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (BinaryOperator '+'
    (DeclRefExpr 'int' Var  'i' )
    (IntegerLiteral 'int' 1)
  )
)

SubABinaryOperator() subbing old variable t in 
i - 1
op -   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable t in 
i + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable t in 
((double) 0.5) * a[i]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (DeclRefExpr 'int' Var  'i' )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable i in 
b[i] = (((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.250000)
    )
    (BinaryOperator '+'
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '-'
          (DeclRefExpr 'int' Var  'i' )
          (IntegerLiteral 'int' 1)
        )
      )
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'i' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.500000)
    )
    (ArraySubscriptExpr (a) 'double' rvalue
      (DeclRefExpr 'double [512]' Var  'a' )
      (DeclRefExpr 'int' Var  'i' )
    )
  )
)

SubABinaryOperator() subbing old variable i in 
((double) 0.25) * (a[i - 1] + a[i + 1]) + ((double) 0.5) * a[i]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (CStyleCastExpr  (double) 
    (FloatingLiteral 'double' 0.500000)
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (DeclRefExpr 'int' Var  'i' )
  )
)

SubABinaryOperator() subbing old variable i in 
((double) 0.25) * (a[i - 1] + a[i + 1])
op *   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'i' )
      (IntegerLiteral 'int' 1)
    )
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'i' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable i in 
a[i - 1] + a[i + 1]
op +   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (BinaryOperator '+'
    (DeclRefExpr 'int' Var  'i' )
    (IntegerLiteral 'int' 1)
  )
)

SubABinaryOperator() subbing old variable i in 
i - 1
op -   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable i in 
i + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable i in 
((double) 0.5) * a[i]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (DeclRefExpr 'int' Var  'i' )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
{[t,i] -> [chill_t1,chill_t2] : t = chill_t1 && 1+i = chill_t2 }
FIX THIS rose in generic loop.cc
loop vars 0 t
loop vars 1 i
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t1 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t1, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t1' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateMinus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 1
2 uninterpreted symbols
loop vars 0 t
loop vars 1 i
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = a[i] = b[i]
sub 0  chill_t1
sub 1  chill_t2 - 1

subbing chill_t1
for  t
subbing chill_t2 - 1
for  i

SubABinaryOperator() subbing old variable t in 
a[i] = b[i]
op =   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (b) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'b' )
  (DeclRefExpr 'int' Var  'i' )
)

SubABinaryOperator() subbing old variable i in 
a[i] = b[i]
op =   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (b) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'b' )
  (DeclRefExpr 'int' Var  'i' )
)

loop.cc LEAVING apply_xform( set )

IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
1->2: 1
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
apply_xform( 0 )
loop.cc apply_xform( set )
{[chill_t1,chill_t2] -> [chill_t3,chill_t4] : chill_t1 = chill_t3 && 2chill_t3+chill_t2 = chill_t4 }
FIX THIS rose in generic loop.cc
loop vars 0 chill_t1
loop vars 1 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreateIdent( chill_t3 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t3, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t3' )
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateTimes()
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateIdent( chill_t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name chill_t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  'chill_t4' )
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE



*** gonna die  *i = 0
2 uninterpreted symbols
loop vars 0 chill_t1
loop vars 1 chill_t2
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

loop.cc stmt[*i].code =


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = b[chill_t2] = (((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1]) + ((double) 0.5) * a[chill_t2])
sub 0  chill_t3
sub 1  -(2 * chill_t3) + chill_t4

subbing chill_t3
for  chill_t1
subbing -(2 * chill_t3) + chill_t4
for  chill_t2

SubABinaryOperator() subbing old variable chill_t1 in 
b[chill_t2] = (((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1]) + ((double) 0.5) * a[chill_t2])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.250000)
    )
    (BinaryOperator '+'
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '-'
          (DeclRefExpr 'int' Var  'chill_t2' )
          (IntegerLiteral 'int' 1)
        )
      )
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'chill_t2' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.500000)
    )
    (ArraySubscriptExpr (a) 'double' rvalue
      (DeclRefExpr 'double [512]' Var  'a' )
      (DeclRefExpr 'int' Var  'chill_t2' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t1 in 
((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1]) + ((double) 0.5) * a[chill_t2]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (CStyleCastExpr  (double) 
    (FloatingLiteral 'double' 0.500000)
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (DeclRefExpr 'int' Var  'chill_t2' )
  )
)

SubABinaryOperator() subbing old variable chill_t1 in 
((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1])
op *   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t2' )
      (IntegerLiteral 'int' 1)
    )
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t2' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t1 in 
a[chill_t2 - 1] + a[chill_t2 + 1]
op +   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (BinaryOperator '+'
    (DeclRefExpr 'int' Var  'chill_t2' )
    (IntegerLiteral 'int' 1)
  )
)

SubABinaryOperator() subbing old variable chill_t1 in 
chill_t2 - 1
op -   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t1 in 
chill_t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t1 in 
((double) 0.5) * a[chill_t2]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (DeclRefExpr 'int' Var  'chill_t2' )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t2 in 
b[chill_t2] = (((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1]) + ((double) 0.5) * a[chill_t2])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.250000)
    )
    (BinaryOperator '+'
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '-'
          (DeclRefExpr 'int' Var  'chill_t2' )
          (IntegerLiteral 'int' 1)
        )
      )
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '+'
          (DeclRefExpr 'int' Var  'chill_t2' )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.500000)
    )
    (ArraySubscriptExpr (a) 'double' rvalue
      (DeclRefExpr 'double [512]' Var  'a' )
      (DeclRefExpr 'int' Var  'chill_t2' )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t2 in 
((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1]) + ((double) 0.5) * a[chill_t2]
op +   rhs type BinaryOperator
(BinaryOperator '*'
  (CStyleCastExpr  (double) 
    (FloatingLiteral 'double' 0.500000)
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (DeclRefExpr 'int' Var  'chill_t2' )
  )
)

SubABinaryOperator() subbing old variable chill_t2 in 
((double) 0.25) * (a[chill_t2 - 1] + a[chill_t2 + 1])
op *   rhs type BinaryOperator
(BinaryOperator '+'
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '-'
      (DeclRefExpr 'int' Var  'chill_t2' )
      (IntegerLiteral 'int' 1)
    )
  )
  (ArraySubscriptExpr (a) 'double' rvalue
    (DeclRefExpr 'double [512]' Var  'a' )
    (BinaryOperator '+'
      (DeclRefExpr 'int' Var  'chill_t2' )
      (IntegerLiteral 'int' 1)
    )
  )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
SubABinaryOperator() subbing old variable chill_t2 in 
a[chill_t2 - 1] + a[chill_t2 + 1]
op +   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (BinaryOperator '+'
    (DeclRefExpr 'int' Var  'chill_t2' )
    (IntegerLiteral 'int' 1)
  )
)

SubABinaryOperator() subbing old variable chill_t2 in 
chill_t2 - 1
op -   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t2 in 
chill_t2 + 1
op +   rhs type IntegerLiteral
(IntegerLiteral 'int' 1)

SubABinaryOperator() subbing old variable chill_t2 in 
((double) 0.5) * a[chill_t2]
op *   rhs type ArraySubscriptExpr
(ArraySubscriptExpr (a) 'double' rvalue
  (DeclRefExpr 'double [512]' Var  'a' )
  (DeclRefExpr 'int' Var  'chill_t2' )
)

SubCStyleCastExpr()  subexpr is type FloatingLiteral
sub in FL
loop.cc LEAVING apply_xform( set )

IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (b)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
IR_roseArraySymbol::IR_roseArraySymbol (a)
dependence graph:
1->1: b:output(1~99, 2~198) b:output(1~99, 2~198)
1->2: b:flow(1~99, 3~199) b:flow(0, 1) a:anti(1~99, 2~198) a:anti(1~99, 4~200) a:anti(0, 2) a:anti(1~99, 3~199) a:anti(0, 1) a:_quasianti(0, 0)
2->1: b:anti(1~99, 1~197) a:flow(1~99, 2~198) a:flow(1~99, 0~196) a:flow(1~99, 1~197)
2->2: a:output(1~99, 2~198) a:output(1~99, 2~198)
CodeGen::CodeGen() sanity checking
num_stmt 2  2 xforms
here goes
here goes
CodeGen::CodeGen() DONE
CG.cc line 164, CG_result::printString()
stmts.size() 2

CG_result::printRepr(ocg, stmts) 
DYINGHERE
s 0/2
result: t4 = Out_1, 0
result: t6 = Out_1, 0
s 1/2
result: t4 = Out_1, 0
result: t6 = Out_1+2t4, 3
return printRepr( ... )
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_utils.cc output_loop() createInvoke( max )
CG_utils.cc output_loop() createInvoke( min )
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5,t6,t7] : t2 <= 2t4+2 }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
{[t1,t2,t3,t4,t5,t6,t7] : TRUE and t2 <= 2t4+2 }
{[t1,t2,t3,t4,t5,t6,t7]: t2 <= 2t4+2}
{[t1,t2,t3,t4,t5,t6,t7] : t2 <= 2t4+2 }
{[t1,t2,t3,t4,t5,t6,t7]: t2 <= 2t4+2}
CG_utils.cc loop_print_repr recursive 3
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()
CG_utils.cc loop_print_repr recursive 4
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_utils.cc output_loop() createInvoke( max )
CG_utils.cc output_loop() createInvoke( min )
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5,t6,t7] : 482+2t4 <= t2 }
output_guard()
GEQ
result =  ocg->CreateAnd(result, term);
CG_utils.cc loop_print_repr recursive 2
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
v Out_1
CG_utils.cc  output_substitutions()          DONE

CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr recursive
loop_print_repr()  guard_repr NULL
CG_utils.cc loop_print_repr() CreateIf()

for(t2 = 4; t2 <= 708; t2 += 32) {
  for(t4 = max(1,intCeil(t2-512,2)); t4 <= min(100,intFloor(t2+28,2)); t4++) {
    if (2*t4 >= t2-2) {
      s0(t4,2*t4+2);
    }
    for(t6 = max(2*t4+3,t2); t6 <= min(2*t4+511,t2+31); t6++) {
      s0(t4,t6);
      s1(t4,-2*t4+t6);
    }
    if (t2 >= 2*t4+482) {
      s1(t4,-2*t4+2*t4+512);
    }
  }
}

script success!
parser.yy almost done
1 loop?   (loop_num_start == loop_num_end)

Loop::getCode( 1 )

CG_result::printRepr(ocg, stmts) 
DYINGHERE
s 0/2
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from 
(DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
result: t6 = Out_1, 0
CG_chillBuilder::CreateIdent( t6 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t6, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't6' )
CG_chillBuilder::CreatePlus()
s 1/2
result: t4 = Out_1, 0
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
result: t6 = Out_1+2t4, 3
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateTimes()
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateIdent( t6 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t6, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't6' )
CG_chillBuilder::CreatePlus()
return printRepr( ... )
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 4 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 708 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 32 )
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )

CG_chillBuilder::CreateInductive()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 100 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 28 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateIntegerFloor()
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 512 )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateIntegerFloor()
CG_chillBuilder::CreateMinus()
CG_utils.cc output_loop() createInvoke( max )
CG_roseBuilder::CreateInvoke( fname max, ...)  NEEDS WORK
max( 1, -(-(t2 - 512) / 2) )
CG_utils.cc output_loop() createInvoke( min )
CG_roseBuilder::CreateInvoke( fname min, ...)  NEEDS WORK
min( 100, (t2 + 28) / 2 )
CG_chillBuilder::CreateInt( 1 )
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )

CG_chillBuilder::CreateInductive()
CG_loop::printRepr() w assigned_on_the_fly
CG.cc  CG_loop printrepr with more arguments
output_guard()
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
then_cond  {[t1,t2,t3,t4,t5,t6,t7] : t2 <= 2t4+2 }
output_guard()
GEQ
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateTimes()
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateIdent( t2 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t2, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't2' )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateMinus()
CG_chillBuilder::CreateLE()
result =  ocg->CreateAnd(result, term);
CG_chillBuilder::CreateAnd()
{[t1,t2,t3,t4,t5,t6,t7] : TRUE and t2 <= 2t4+2 }
{[t1,t2,t3,t4,t5,t6,t7]: t2 <= 2t4+2}
{[t1,t2,t3,t4,t5,t6,t7] : t2 <= 2t4+2 }
{[t1,t2,t3,t4,t5,t6,t7]: t2 <= 2t4+2}
CG_utils.cc loop_print_repr recursive 3
loop_print_repr()  guard_repr NOT NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreateTimes()
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateInt( 2 )
CG_chillBuilder::CreatePlus()
CG_chillBuilder::CreateAnd()
CG_split::printRepr()
loop_print_repr()  guard_repr NULL
CG.cc  CG_loop printrepr with more arguments
CG_chillBuilder::CreateInt( 0 )
CG_chillBuilder::CreateAnd()
CG_leaf::printRepr()
CG_utils.cc  output_substitutions()
v Out_1
CG_chillBuilder::CreateIdent( t4 )
chillAST_VarDecl::chillAST_VarDecl( type int, name t4, arraypart  parent )
made a new chillRepr from (DeclRefExpr 'int' Var  't4' )
CG_chillBuilder::CreatePlus()
v Out_1
CG_chillBuilder::CreatePlus()
CG_utils.cc  output_substitutions()          DONE

chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
0.25  0.25
chillAST_FloatingLiteral::clone()  allthedigits (nil) 
chillAST_FloatingLiteral::chillAST_FloatingLiteral( old ) allthedigits (nil)
0.5  0.5
chillAST_BinaryOperator, op '=', lhs is an array reference  LVALUE


in CG_xxxxBuilder.cc (OMEGA)  CG_xxxxBuilder::CreateSubstitutedStmt()
2 vars and 2 substitutions
1 nodes in old code. was:
stmt(0) = b[-(2 * chill_t3) + chill_t4] = (((double) 0.25) * (a[-(2 * chill_t3) + chill_t4 - 1] + a[(-(2 * chill_t3) + chill_t4) + 1]) + ((double) 0.5) * a[-(2 * chill_t3) + chill_t4])
sub 0  t4
sub 1  2 * t4 + 2

subbing t4
for  chill_t3
subbing 2 * t4 + 2
for  chill_t4

SubABinaryOperator() subbing old variable chill_t3 in 
b[-(2 * chill_t3) + chill_t4] = (((double) 0.25) * (a[-(2 * chill_t3) + chill_t4 - 1] + a[(-(2 * chill_t3) + chill_t4) + 1]) + ((double) 0.5) * a[-(2 * chill_t3) + chill_t4])
op =   rhs type BinaryOperator
(BinaryOperator '+'
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.250000)
    )
    (BinaryOperator '+'
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '-'
          (BinaryOperator '+'
            (UnaryOperator prefix -
              (BinaryOperator '*'
                (IntegerLiteral 'int' 2)
                (DeclRefExpr 'int' Var  'chill_t3' )
              )
            )
            (DeclRefExpr 'int' Var  'chill_t4' )
          )
          (IntegerLiteral 'int' 1)
        )
      )
      (ArraySubscriptExpr (a) 'double' rvalue
        (DeclRefExpr 'double [512]' Var  'a' )
        (BinaryOperator '+'
          (BinaryOperator '+'
            (UnaryOperator prefix -
              (BinaryOperator '*'
                (IntegerLiteral 'int' 2)
                (DeclRefExpr 'int' Var  'chill_t3' )
              )
            )
            (DeclRefExpr 'int' Var  'chill_t4' )
          )
          (IntegerLiteral 'int' 1)
        )
      )
    )
  )
  (BinaryOperator '*'
    (CStyleCastExpr  (double) 
      (FloatingLiteral 'double' 0.500000)
    )
    (ArraySubscriptExpr (a) 'double' rvalue
      (DeclRefExpr 'double [512]' Var  'a' )
      (BinaryOperator '+'
        (UnaryOperator prefix -
          (BinaryOperator '*'
            (IntegerLiteral 'int' 2)
            (DeclRefExpr 'int' Var  'chill_t3' )
          )
        )
        (DeclRefExpr 'int' Var  'chill_t4' )
      )
    )
  )
)

SubABinaryOperator() subbing old variable chill_t3 in 
-(2 * chill_t3) + chill_t4
op +   rhs type DeclRefExpr
(DeclRefExpr 'int' Var  'chill_t4' )


CG_chillBuilder.cc substituteChill() UNHANDLED statement of type (UnaryOperator prefix -
  (BinaryOperator '*'
    (IntegerLiteral 'int' 2)
    (DeclRefExpr 'int' Var  'chill_t3' )
  )
)
   -(2 * chill_t3)
UnaryOperator
